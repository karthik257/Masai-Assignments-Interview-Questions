HTML - CSS - WEB - JS

What is the DOM?

The DOM (Document Object Model) is a cross-platform API that treats HTML and XML documents as a tree structure consisting of nodes. These nodes (such as elements and text nodes) are objects that can be programmatically manipulated and any visible changes made to them are reflected live in the document. In a browser, this API is available to JavaScript where DOM nodes can be manipulated to change their styles, contents, placement in the document, or interacted with through event listeners.

Describe z-index and how stacking context is formed.

The z-index property in CSS controls the vertical stacking order of elements that overlap. z-index only affects elements that have a position value which is not static.

Without any z-index value, elements stack in the order that they appear in the DOM (the lowest one down at the same hierarchy level appears on top). Elements with non-static positioning (and their children) will always appear on top of elements with default static positioning, regardless of HTML hierarchy.

A stacking context is an element that contains a set of layers. Within a local stacking context, the z-index values of its children are set relative to that element rather than to the document root. Layers outside of that context — i.e. sibling elements of a local stacking context — can't sit between layers within it. If an element B sits on top of element A, a child element of element A, element C, can never be higher than element B even if element C has a higher z-index than element B.

Each stacking context is self-contained - after the element's contents are stacked, the whole element is considered in the stacking order of the parent stacking context. A handful of CSS properties trigger a new stacking context, such as opacity less than 1, filter that is not None, and transform that is not none.

Why is it generally a good idea to position CSS <link> s between <head></head> and JS <script> s just before </body>? Do you know any exceptions?

The main reason as to why JS files are linked at the bottom of the body is because whenever a browser encounters any JS, it parses it and executes that on the spot. Hence if it was to be added at the top, it would make the page rendering slow and thus it would take more time for page load. Moreover since the DOM won't be rendered fully, JS won't be able to manipulate the elements.
However if you use Jquery, that won't be an issue since it would execute only after the document is ready. But since in any case, the browser would parse it, it would slow the page load.
On the contrary, CSS files are linked in the head because they get applied regardless of DOM already rendered or not. Hence the webpage looks elegant as soon as the page loads. However just like JS you can link the CSS at the end which would mean that the webpage first loads with just plain HTML and then the CSS is applied to it. This shift is clearly visible to the user and moreover an important thing to remember is that the page would load with bare minimum HTML and if the user has slow Internet connection, the CSS load would take considerable amount of time, which means that the webpage shows just the HTML meanwhile. This might make the user close the website without waiting for it to load fully.
To avoid such things, a CSS file is linked at the head while a JS file is linked at the bottom.

What is HTML5 Web Storage? Explain localStorage and sessionStorage.

With HTML5, web pages can store data locally within the user’s browser. The data is stored in name/value pairs, and a web page can only access data stored by itself.

Differences between localStorage and sessionStorage regarding lifetime:

Data stored through localStorage is permanent: it does not expire and remains stored on the user’s computer until a web app deletes it or the user asks the browser to delete it.
sessionStorage has the same lifetime as the top-level window or browser tab in which the data got stored. When the tab is permanently closed, any data stored through sessionStorage is deleted.
Differences between localStorage and sessionStorage regarding storage scope: Both forms of storage are scoped to the document origin so that documents with different origins will never share the stored objects.

sessionStorage is also scoped on a per-window basis. Two browser tabs with documents from the same origin have separate sessionStorage data.
Unlike in localStorage, the same scripts from the same origin can't access each other's sessionStorage when opened in different tabs.

Briefly describe the correct usage of the following HTML5 semantic elements: <header>, <article>,<section>, <footer>

<header> is used to contain introductory and navigational information about a section of the page. This can include the section heading, the author’s name, time and date of publication, table of contents, or other navigational information.

<article> is meant to house a self-contained composition that can logically be independently recreated outside of the page without losing its meaning. Individual blog posts or news stories are good examples.

<section> is a flexible container for holding content that shares a common informational theme or purpose.

<footer> is used to hold information that should appear at the end of a section of content and contain additional information about the section. Author’s name, copyright information, and related links are typical examples of such content.


What are the building blocks of HTML5?

Semantics: allowing you to describe more precisely what your content is.
Connectivity: allowing you to communicate with the server in new and innovative ways.

Offline and storage: allowing web pages to store data on the client-side locally and operate offline more efficiently.

Multimedia: making video and audio first-class citizens in the Open Web.
2D/3D graphics and effects: allowing a much more diverse range of presentation options.

Performance and integration: providing greater speed optimization and better usage of computer hardware.

Device access: allowing for the usage of various input and output devices.
Styling: letting authors write more sophisticated themes.



What is the difference between a <span> and a <div> ?

<div> is a block level element which means it will render it on it's own line with a width of a 100% of the parent element.

<span> is an inline element which means it will render on the same line as the previous element, if it is also an inline element, and it's width will be determined by its content

When to use css grid and flexbox?

CSS Grid Layout is a two-dimensional system, meaning it can handle both columns and rows, unlike flexbox which is largely a one-dimensional system (either in a column or a row).

A core difference between CSS Grid and Flexbox is that — CSS Grid’s approach is layout-first while Flexbox’ approach is content-first. If you are well aware of your content before making layout, then blindly opt for Flexbox and if not, opt for CSS Grid.

Flexbox layout is most appropriate to the components of an application (as most of them are fundamentally linear), and small-scale layouts, while the Grid layout is intended for larger-scale layouts which aren’t linear in their design.

If you only need to define a layout as a row or a column, then you probably need flexbox. If you want to define a grid and fit content into it in two dimensions — you need the grid.


How to make page responsive?

Responsive Web Design is about using HTML and CSS to automatically resize, hide, shrink, or enlarge, a website, to make it look good on all devices (desktops, tablets, and phones).

Setting the viewport

<meta name="viewport" content="width=device-width, initial-scale=1.0">

Responsive Images

If the CSS width property is set to 100%, the image will be responsive and scale up and down

Show different Images depending on Browser Width

The HTML <picture> element allows you to define different images for different browser window sizes.

Responsive Text Size

The text size can be set with a "vw" unit, which means the "viewport width". That way the text size will follow the size of the browser window.

Media Queries

Using media queries you can define completely different styles for different browser sizes.

What is difference between Select and Datalist?

For the select element, the user is required to select one of the options you've given. For the datalist element, it is suggested that the user select one of the options you've given, but he can actually enter anything he wants in the input.

Select-Option

<select name="browser">
  <option value="firefox">Firefox</option>
  <option value="ie">IE</option>
  <option value="chrome">Chrome</option>
  <option value="opera">Opera</option>
  <option value="safari">Safari</option>
</select>

Datalist-Option

<input type="text" list="browsers">
<datalist id="browsers">
  <option value="Firefox">
  <option value="IE">
  <option value="Chrome">
  <option value="Opera">
  <option value="Safari">
</datalist>

What are optional closing tag?

<p>, <li>, <td>, <tr>, <th>, <html>, <body>, etc. don't have to provide end tag. Whenever browser hits a new tag it automatically ends the previous tag.

Why you would like to use semantic tag?

Search Engine Optimization, accessibility, repurposing, light code.

Many visually impaired person rely on browser speech and semantic tag helps to interpret page content clearly.

Search engine needs to understand page content to rank and semantic tag helps.

Semantic code aids accessibility. Specially, many people whose eyes are not good rely on speech browsers to read pages to them. These programs cannot interpret pages very well unless they are clearly explained.

Help Search engines to better understand pages. Search engine need to understand what your content is about when rank you properly on search engines. Semantic code tends to improve your placement on search engines, as it is easier for the "search engine spiders" to understand.


It’s easier to read and edit, which saves time and money during maintenance.
Explain the difference between layout, painting and compositing?



JavaScript: Typically JavaScript is used to handle work that will result in visual changes, whether it’s jQuery’s animate function, sorting a data set, or adding DOM elements to the page. It doesn’t have to be JavaScript that triggers a visual change, though: CSS Animations, Transitions, and the Web Animations API are also commonly used.

Style calculations: This is the process of figuring out which CSS rules apply to which elements based on matching selectors, for example, .headline or .nav > .nav__item. From there, once rules are known, they are applied and the final styles for each element are calculated.

Layout: Once the browser knows which rules apply to an element it can begin to calculate how much space it takes up and where it is on screen. The web’s layout model means that one element can affect others, for example the width of the element typically affects its children’s widths and so on all the way up and down the tree, so the process can be quite involved for the browser.

Paint: Painting is the process of filling in pixels. It involves drawing out text, colors, images, borders, and shadows, essentially every visual part of the elements. The drawing is typically done onto multiple surfaces, often called layers.

Compositing: Since the parts of the page were drawn into potentially multiple layers they need to be drawn to the screen in the correct order so that the page renders correctly. This is especially important for elements that overlap another, since a mistake could result in one element appearing over the top of another incorrectly.


The difference between block, inline and inline-block element?

Block Elements

The block elements always start on a new line. They will also take space of an entire row or width. List of block elements are <p>, <h1>, <div>, <header>.

Example:

<p>
  Lorem ipsum dolor sit amet consectetur adipisicing elit. Unde autem,
  consequatur deleniti nobis beatae quo dolore nemo corporis. Ad delectus
  dignissimos pariatur illum eveniet dolor rem eius laborum sed iure!
</p>

<p>
  Lorem ipsum dolor sit amet consectetur adipisicing elit. Unde autem,
  consequatur deleniti nobis beatae quo dolore nemo corporis. Ad delectus
  dignissimos pariatur illum eveniet dolor rem eius laborum sed iure!
</p>

Inline Elements

Inline elements don’t start on a new line, they appear on the same line as the content and tags beside them. Some examples of inline elements are <a>, <span> , <strong>, and <img> tags.

When it comes to margins and padding, browsers treat inline elements differently. You can add space to the left and right on an inline element, but you cannot add height to the top or bottom padding or margin of an inline element.

<a href="#">Link</a>
<img src="https://picsum.photos/30" />
<span>Span</span>
<strong>Strong Player</strong>

Inline-Block Elements

Inline-block elements are similar to inline elements, except they can have padding and margins added on all four sides. One common use for using inline-block is for creating navigation links horizontally. Some examples of inline-block elements are <input>, <button>, <select>, <textarea> etc.

input {
  width: 300px;
  height: 50px;
}

button {
  width: 100px;
  height: 50px;
  margin-top: 20px;
}

<input type="text" /> <button>Submit</button>


What is pseudo element? 

Pseudo Element: A CSS pseudo-element is used to style specified parts of an element.

For example, it can be used to:

Style the first letter, or line, of an element
Insert content before, or after, the content of an element

Example CSS Pseudo Elements: 
https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-elements

What is pseudo class?

Pseudo-classes: A pseudo-class is used to define a special state of an element.

For example, it can be used to:

Style an element when a user mouses over it

Style visited and unvisited links differently

Style an element when it gets focus

Example CSS Pseudo Classes
https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-classes

What elements will match each of the following CSS selectors

div, p Selects all <div> elements and all
elements

div p Selects all <p> elements that are anywhere inside a
element
div > p Selects all <p> elements where the immediate parent is a
element
div + p Selects all <p> elements that are placed immediately after a
element
div ~ p Selects all <p> elements that are anywhere preceded by a
Element

Explain the meaning of each of these CSS units for expressing length:

cm centimeters em elements (i.e., relative to the font-size of the element; e.g., 2 em means 2 times the current font size) in inches mm millimeters pc picas (1 pc = 12 pt = 1/6th of an inch) pt points (1 pt = 1/72nd of an inch) px pixels (1 px = 1/96th of an inch)

In CSS3, how would you select

Every <a> element whose href attribute value begins with “https”.
  a[href^="https"]
Every <a> element whose href attribute value ends with “.pdf”.
  a[href$=".pdf"]
Every <a> element whose href attribute value contains the substring “css”.
  a[href*="css"]

What is the purpose of the box-sizing property?

The box-sizing CSS property sets how the total width and height of an element is calculated.

content-box: the default width and height values apply to the element's content only. The padding and border are added to the outside of the box.

padding-box: Width and height values apply to the element's content and its padding. The border is added to the outside of the box. Currently, only Firefox supports the padding-box value.

border-box: Width and height values apply to the content, padding, and border.
inherit: inherits the box sizing of the parent element.

Example:

box-sizing: content-box;
width: 100%;
border: solid rgb(90,107,204) 10px;
padding: 5px;

How to create a zebra striped table with CSS?

To create a zebra-striped table, use the nth-child() selector and add a background-color to all even (or odd) table rows:

tr:nth-child(even) {
    background-color: #f2f2f2
}

What is the difference between RGBa, HEX and HSLa?

RGB (Red/Green/Blue) is a color model.

p {
  color: rgba(37, 84, 127, 1);
}

HEX (Hexadecimal color values)

p {
  color: #25547f;
}

HSLa (Hue Saturation Lightness alpha)
p {
  color: hsla(209, 55%, 32%, 1);
}

What is CSS preprocessor?

Pre-processors extend CSS with variables, operators, interpolations, functions, mixins and many more other usable assets. After development, these specific files are compiled into regular CSS that any browser can understand. Pre-processor help writing reusable, easily maintainable and extensible codes in CSS.

CSS preprocessors

SASS (SCSS)
LESS
Stylus
PostCSS

Advantages:

CSS is made more maintainable.
Easy to write nested selectors.
Variables for consistent theming. Can share theme files across different projects.
Mixins to generate repeated CSS.
Splitting your code into multiple files. CSS files can be split up too but doing so will require an HTTP request to download each CSS file

What is the difference between "resetting" and "normalizing" CSS?

1. Resetting: CSS resets aim to remove all built-in browser styling. For example margins, paddings, font-sizes of all elements are reset to be the same. You will have to redeclare styling for common typographic elements.

Example

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, 
acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, 
sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, 
caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed,  figure, figcaption, 
footer, header, hgroup,  menu, nav, output, ruby, section, summary, time, mark, audio, video {  
   margin: 0;  
   padding: 0;  
   border: 0;  
   font-size: 100%;  
   font: inherit;  
   vertical-align: baseline; 
}

2. Normalizing: Normalize CSS aims to make built-in browser styling consistent across browsers. It also corrects bugs for common browser dependencies.

/* 
  Correct the font size and margin on `h1` elements within `section`  
  and `article` contexts in Chrome, Firefox, and Safari.
*/
 h1 {  font-size: 2em;  margin: 0.67em 0;}



Describe clear Property in CSS?

The clear property specifies what elements can float beside the cleared element and on which side.
Sl.No
Properties
Description
01.
clear: none
Allows floating elements on both sides. This is default
02.
clear: left
No floating elements allowed on the left side
03.
clear: right
No floating elements allowed on the right side
04.
clear: both
No floating elements allowed on either the left or the right side
05.
clear: inherit
The element inherits the clear value of its parent

What is a focus ring? What is the correct solution to handle them?

A focus ring is a visible outline given to focusable elements such as buttons and anchor tags. It varies depending on the vendor, but generally it appears as a blue outline around the element to indicate it is currently focused.

In the past, many people specified outline: 0; on the element to remove the focus ring. However, this causes accessibility issues for keyboard users because the focus state may not be clear. When not specified though, it causes an unappealing blue ring to appear around an element.

In recent times, frameworks like Bootstrap have opted to use a more appealing box-shadow outline to replace the default focus ring. However, this is still not ideal for mouse users.

The best solution is an upcoming pseudo-selector :focus-visible which can be polyfilled today with JavaScript. It will only show a focus ring if the user is using a keyboard and leave it hidden for mouse users. This keeps both aesthetics for mouse use and accessibility for keyboard use.

Describe the layout of the CSS Box Model and briefly describe each component.

Content: The inner-most part of the box filled with content, such as text, an image, or video player. It has the dimensions content-box width and content-box height.

Padding: The transparent area surrounding the content. It has dimensions padding-box width and padding-box height.

Border: The area surrounding the padding (if any) and content. It has dimensions border-box width and border-box height.

Margin: The transparent outer-most layer that surrounds the border. It separates the element from other elements in the DOM. It has dimensions margin-box width and margin-box height.






What is the difference between em and rem units?

Both em and rem units are based on the font-size CSS property. The only difference is where they inherit their values from.

em units inherit their value from the font-size of the parent element
rem units inherit their value from the font-size of the root element (html)
In most browsers, the font-size of the root element is set to 16px by default.


Using flexbox, create a 3-column layout where each column takes up a col-{n} / 12 ratio of the container.

<div class="row">
  <div class="col-2"></div>
  <div class="col-7"></div>
  <div class="col-3"></div>
</div>

Set the .row parent to display: flex; and use the flex shorthand property to give the column classes a flex-grow value that corresponds to its ratio value.

.row {
  display: flex;
}

.col-2 {
  flex: 2;
}

.col-7 {
  flex: 7;
}

.col-3 {
  flex: 3;
}

Can you name the four types of @media properties?

all, which applies to all media type devices
print, which only applies to printers
screen, which only applies to screens (desktops, tablets, mobile etc.)
speech, which only applies to screen readers

What are the advantages of using CSS sprites and how are they utilized?

CSS sprites combine multiple images into one image, limiting the number of HTTP requests a browser has to make, thus improving load times. Even under the new HTTP/2 protocol, this remains true.

Under HTTP/1.1, at most one request is allowed per TCP connection. With HTTP/1.1, modern browsers open multiple parallel connections (between 2 to 8) but it is limited. With HTTP/2, all requests between the browser and the server are multiplexed on a single TCP connection. This means the cost of opening and closing multiple connections is mitigated, resulting in a better usage of the TCP connection and limits the impact of latency between the client and server. It could then become possible to load tens of images in parallel on the same TCP connection.

However, according to benchmark results, although HTTP/2 offers 50% improvement over HTTP/1.1, in most cases the sprite set is still faster to load than individual images.

To utilize a spritesheet in CSS, one would use certain properties, such as background-image, background-position and background-size to ultimately alter the background of an element.

Can you describe how CSS specificity works?

Assuming the browser has already determined the set of rules for an element, each rule is assigned a matrix of values, which correspond to the following from highest to lowest specificity:

Inline rules (binary - 1 or 0)
Number of id selectors
Number of class, pseudo-class and attribute selectors
Number of tags and pseudo-element selectors

When two selectors are compared, the comparison is made on a per-column basis (e.g. an id selector will always be higher than any amount of class selectors, as ids have higher specificity than classes). In cases of equal specificity between multiple rules, the rules that comes last in the page's style sheet is deemed more specific and therefore applied to the element.

What is the purpose of the alt attribute on images?

The alt attribute provides alternative information for an image if a user cannot view it. The alt attribute should be used to describe any images except those which only serve a decorative purpose, in which case it should be left empty.

What is the purpose of cache busting and how can you achieve it?

Browsers have a cache to temporarily store files on websites so they don't need to be re-downloaded again when switching between pages or reloading the same page. The server is set up to send headers that tell the browser to store the file for a given amount of time. This greatly increases website speed and preserves bandwidth.

However, it can cause problems when the website has been changed by developers because the user's cache still references old files. This can either leave them with old functionality or break a website if the cached CSS and JavaScript files are referencing elements that no longer exist, have moved or have been renamed.

Cache busting is the process of forcing the browser to download the new files. This is done by naming the file something different to the old file.

A common technique to force the browser to re-download the file is to append a query string to the end of the file.

src="js/script.js" => src="js/script.js?v=2"

The browser considers it a different file but prevents the need to change the file name.

Can a web page contain multiple <header> elements? What about <footer> elements?

Yes to both. The W3 documents state that the tags represent the header(<header>) and footer(<footer>) areas of their nearest ancestor "section". So not only can the page <body> contain a header and a footer, but so can every <article> and <section> element.


What are defer and async attributes on a <script> tag?

If neither attribute is present, the script is downloaded and executed synchronously, and will halt parsing of the document until it has finished executing (default behavior). Scripts are downloaded and executed in the order they are encountered.

The defer attribute downloads the script while the document is still parsing but waits until the document has finished parsing before executing it, equivalent to executing inside a DOMContentLoaded event listener. defer scripts will execute in order.

The async attribute downloads the script during parsing the document but will pause the parser to execute the script before it has fully finished parsing. async scripts will not necessarily execute in order.

Note: both attributes must only be used if the script has a src attribute (i.e. not an inline script).

<script src="myscript.js"></script>
<script src="myscript.js" defer></script>
<script src="myscript.js" async></script>

Discuss the differences between an HTML specification and a browser’s implementation thereof.

HTML specifications such as HTML5 define a set of rules that a document must adhere to in order to be “valid” according to that specification. In addition, a specification provides instructions on how a browser must interpret and render such a document.

A browser is said to “support” a specification if it handles valid documents according to the rules of the specification. As of yet, no browser supports all aspects of the HTML5 specification (although all of the major browser support most of it), and as a result, it is necessary for the developer to confirm whether the aspect they are making use of will be supported by all of the browsers on which they hope to display their content. This is why cross-browser support continues to be a headache for developers, despite the improved specifications.

What is the difference between HTML and React event handling?

In HTML, the attribute name is in all lowercase and is given a string invoking a function defined somewhere:

<button onclick="handleClick()"></button>

In React, the attribute name is camelCase and are passed the function reference inside curly braces:

<button onClick={handleClick} />

In HTML, false can be returned to prevent default behavior, whereas in React preventDefault has to be called explicitly.

<a href="#" onclick="console.log('The link was clicked.'); return false" />
function handleClick(e) {
  e.preventDefault()
  console.log("The link was clicked.")
}

What are some differences that XHTML has compared to HTML?

Some of the key differences are:

An XHTML element must have an XHTML <DOCTYPE>
Attributes values must be enclosed in quotes
Attribute minimization is forbidden (e.g. one has to use checked="checked" instead of checked)
Elements must always be properly nested
Elements must always be closed
Special characters must be escaped

Where and why is the rel="noopener" attribute used?

The rel="noopener" is an attribute used in <a> elements (hyperlinks). It prevents pages from having a window.opener property, which would otherwise point to the page from where the link was opened and would allow the page opened from the hyperlink to manipulate the page where the hyperlink is.

What's the difference between a relative, fixed, absolute and statically positioned element?
A positioned element is an element whose computed position property is either relative, absolute, fixed or sticky.

static - The default position; the element will flow into the page as it normally would. The top, right, bottom, left and z-index properties do not apply.

relative - The element's position is adjusted relative to itself, without changing layout (and thus leaving a gap for the element where it would have been had it not been positioned).

absolute - The element is removed from the flow of the page and positioned at a specified position relative to its closest positioned ancestor if any, or otherwise relative to the initial containing block. Absolutely positioned boxes can have margins, and they do not collapse with any other margins. These elements do not affect the position of other elements.

fixed - The element is removed from the flow of the page and positioned at a specified position relative to the viewport and doesn't move when scrolled.

sticky - Sticky positioning is a hybrid of relative and fixed positioning. The element is treated as relative positioned until it crosses a specified threshold, at which point it is treated as fixed positioned.

What existing CSS frameworks have you used locally, or in production? How would you change/improve them?

Bootstrap - Slow release cycle. Bootstrap 4 has been in alpha for almost 2 years. Add a spinner button component, as it is widely used.

Semantic UI - Source code structure makes theme customization extremely hard to understand. Its unconventional theming system is a pain to customize. Hardcoded config path within the vendor library. Not well-designed for overriding variables unlike in Bootstrap.

Bulma - A lot of non-semantic and superfluous classes and markup required. Not backward compatible. Upgrading versions breaks the app in subtle manners.

How would you implement a web design comp that uses non-standard fonts?

Use @font-face and define font-family for different font-weights.
Explain how a browser determines what elements match a CSS selector.

This part is related to the above about writing efficient CSS. Browsers match selectors from rightmost (key selector) to left. Browsers filter out elements in the DOM according to the key selector and traverse up its parent elements to determine matches. The shorter the length of the selector chain, the faster the browser can determine if that element matches the selector.

For example with this selector p span, browsers firstly find all the <span> elements and traverse up its parent all the way up to the root to find the <p> element. For a particular <span>, as soon as it finds a <p>, it knows that the <span> matches and can stop its matching.


What are the building blocks of HTML5?

Semantics: allowing you to describe more precisely what your content is.
Connectivity: allowing you to communicate with the server in new and innovative ways.
Offline and storage: allowing webpages to store data on the client-side locally and operate offline more efficiently.
Multimedia: making video and audio first-class citizens in the Open Web.
2D/3D graphics and effects: allowing a much more diverse range of presentation options.
Performance and integration: providing greater speed optimization and better usage of computer hardware.
Device access: allowing for the usage of various input and output devices.
Styling: letting authors write more sophisticated themes.

What is Critical Rendering Path?

Constructing the DOM Tree
Constructing the CSSOM Tree
Running JavaScript - parser blocking resource
Creating the Render Tree
Generating the Layout
Painting

What is the purpose of main element?

The HTML <main> element represents the dominant content of the of a document. The main content area consists of content that is directly related to or expands upon the central topic of a document, or the central functionality of an application.

<main role="main">
    <p>Geckos are a group of usually small, usually nocturnal lizards. 
       They are found on every continent except Australia.</p>
    <p>Many species of gecko have adhesive toe pads which enable them to climb walls and even windows.</p>
</main>

Note: A document mustn't have more than one <main> element that doesn't have the hidden attribute specified.

Name 3 ways to decrease page load?

LocalStorage
Caching resources
DNS-prefetch (sample below)
Keep resources on a CDN

Explain some of the pros and cons for CSS animations versus JavaScript animations.

Regarding optimization and responsiveness the debate bounces back and forth but, the concept is:

CSS animations allows the browser to choose where the animation processing is done, CPU or the GPU. (Central or Graphics Processing Unit)

That said, adding many layers to a document will eventually have a performance hit.

JS animation means more code for the user to download and for the developer to maintain.

Applying multiple animation types on an element is harder with CSS since all transforming power is in one property transform

CSS animations being declarative are not programmable therefore limited in capability.
What does CORS stand for and what issue does it address?

Cross-Origin Resource Sharing (CORS) is a W3C spec that allows cross-domain communication from the browser. By building on top of the XMLHttpRequest object, CORS allows developers to work with the same idioms as same-domain requests. CORS gives web servers cross-domain access controls, which enable secure cross-domain data transfers.

What is desktop first and mobile first design approach

Desktop first : General selectors and styles designed to make the site look good on DESKTOP screens defined globally. But they affect all devices, and must be overridden by max-width media queries targeting minimum screen size

Mobile First : General selectors and styles designed to make the site look good on small MOBILE screens go here. But they affect all devices, and must be overridden by min-width media queries targeting maximum scrren size

In desktop first approach the media queries will be written with respect to max-width whereas in mobile first approach media queries will be written with respect to min-width

What are data- attributes good for?

The HTML5 data attribute lets you assign custom data to an element. When we want to store more information/data about the element when no suitable HTML5 element or attribute exists

What is a self closing tag?

In HTML5 it is not strictly necessary to close certain HTML tags. The tags that aren’t required to have specific closing tags are called “self closing” tags.

An example of a self closing tag is something like a line break (<br />) or the meta tag (<meta>). This means that the following are both acceptable:

<meta charset="UTF-8">
...
<meta charset="UTF-8" />

Does the following trigger http request at the time of page load?

<img src="mypic.jpg" style="visibility: hidden" alt="My photo">

<div style="display: none;">
    <img src="mypic.jpg" alt="My photo">
</div>

Describe floats and how they work.

Float is a CSS positioning property. Floated elements remain a part of the flow of the page, and will affect the positioning of other elements (e.g. text will flow around floated elements), unlike position: absolute elements, which are removed from the flow of the page.

The CSS clear property can be used to be positioned below left/right/both floated elements.

If a parent element contains nothing but floated elements, its height will be collapsed to nothing. It can be fixed by clearing the float after the floated elements in the container but before the close of the container.

The .clearfix hack uses a clever CSS pseudo selector (:after) to clear floats. Rather than setting the overflow on the parent, you apply an additional class clearfix to it. Then apply this CSS:

.clearfix:after {
  content: " ";
  visibility: hidden;
  display: block;
  height: 0;
  clear: both;
}

Alternatively, give overflow: auto or overflow: hidden property to the parent element which will establish a new block formatting context inside the children and it will expand to contain its children.

Describe Block Formatting Context (BFC) and how it works.

A Block Formatting Context (BFC) is part of the visual CSS rendering of a web page in which block boxes are laid out. Floats, absolutely positioned elements, inline-blocks, table-cells, table-captions, and elements with overflow other than visible (except when that value has been propagated to the viewport) establish new block formatting contexts.

Knowing how to establish a block formatting context is important, because without doing so, the containing box will not contain floated children. This is similar to collapsing margins, but more insidious as you will find entire boxes collapsing in odd ways.

A BFC is an HTML box that satisfies at least one of the following conditions:

The value of float is not none.
The value of position is neither static nor relative.
The value of display is table-cell, table-caption, inline-block, flex, or inline-flex.
The value of overflow is not visible.
In a BFC, each box's left outer edge touches the left edge of the containing block (for right-to-left formatting, right edges touch).

Vertical margins between adjacent block-level boxes in a BFC collapse. Read more on collapsing margins.

What are the various clearing techniques and which is appropriate for what context?

Empty div method - <div style="clear:both;"></div>.
Clearfix method - Refer to the .clearfix class above.
overflow: auto or overflow: hidden method - Parent will establish a new block formatting context and expand to contains its floated children.

In large projects, I would write a utility .clearfix class and use them in places where I need it. overflow: hidden might clip children if the children is taller than the parent and is not very ideal.

How would you approach fixing browser-specific styling issues?

After identifying the issue and the offending browser, use a separate style sheet that only loads when that specific browser is being used. This technique requires server-side rendering though.
Use libraries like Bootstrap that already handles these styling issues for you.
Use autoprefixer to automatically add vendor prefixes to your code.
Use Reset CSS or Normalize.css.
If you're using Postcss (or a similar transpiling library), there may be plugins which allow you to opt in for using modern CSS syntax (and even W3C proposals) that will transform those sections of your code into corresponding safe code that will work in the targets you've used.

What are the different ways to visually hide content (and make it available only for screen readers)?

These techniques are related to accessibility (a11y).

width: 0; height: 0. Make the element not take up any space on the screen at all, resulting in not showing it.
position: absolute; left: -99999px. Position it outside of the screen.
text-indent: -9999px. This only works on text within the block elements.
Metadata. For example by using Schema.org, RDF, and JSON-LD.
WAI-ARIA. A W3C technical specification that specifies how to increase the accessibility of web pages.

Even if WAI-ARIA is the ideal solution, I would go with the absolute positioning approach, as it has the least caveats, works for most elements and it's an easy technique.

Are you familiar with styling SVG?

Yes, there are several ways to color shapes (including specifying attributes on the object) using inline CSS, an embedded CSS section, or an external CSS file. Most SVG you'll find around the web use inline CSS, but there are advantages and disadvantages associated with each type.

Basic coloring can be done by setting two attributes on the node: fill and stroke. fill sets the color inside the object and stroke sets the color of the line drawn around the object. You can use the same CSS color naming schemes that you use in HTML, whether that's color names (that is red), RGB values (that is rgb(255,0,0)), Hex values, RGBA values, etc.

<rect
  x="10"
  y="10"
  width="100"
  height="100"
  stroke="blue"
  fill="purple"
  fill-opacity="0.5"
  stroke-opacity="0.8"
/>

The above fill="purple" is an example of a presentational attribute. Interestingly, and unlike inline styles like style="fill: purple" which also happens to be an attribute, presentational attributes can be overriden by CSS styles defined in a stylesheet. So, if you did something like svg { fill: blue; } it would override the purple fill we've defined.

What are some of the "gotchas" for writing efficient CSS?

Firstly, understand that browsers match selectors from rightmost (key selector) to left. Browsers filter out elements in the DOM according to the key selector and traverse up its parent elements to determine matches. The shorter the length of the selector chain, the faster the browser can determine if that element matches the selector. Hence avoid key selectors that are tag and universal selectors. They match a large number of elements and browsers will have to do more work in determining if the parents do match.

BEM (Block Element Modifier) methodology recommends that everything has a single class, and, where you need hierarchy, that gets baked into the name of the class as well, this naturally makes the selector efficient and easy to override.

Be aware of which CSS properties trigger reflow, repaint, and compositing. Avoid writing styles that change the layout (trigger reflow) where possible.

What are the advantages/disadvantages of using CSS preprocessors?

Advantages:

CSS is made more maintainable.
Easy to write nested selectors.
Variables for consistent theming. Can share theme files across different projects.
Mixins to generate repeated CSS.
Sass features like loops, lists, and maps can make configuration easier and less verbose.
Splitting your code into multiple files. CSS files can be split up too but doing so will require an HTTP request to download each CSS file.

Disadvantages:

Requires tools for preprocessing. Re-compilation time can be slow.
Not writing currently and potentially usable CSS. For example, by using something like postcss-loader with webpack, you can write potentially future-compatible CSS, allowing you to use things like CSS variables instead of Sass variables. Thus, you're learning new skills that could pay off if/when they become standardized.

Describe what you like and dislike about the CSS preprocessors you have used.

Likes:

Mostly the advantages mentioned above.
Less is written in JavaScript, which plays well with Node.

Dislikes:

I use Sass via node-sass, which is a binding for LibSass written in C++. I have to frequently recompile it when switching between node versions.
In Less, variable names are prefixed with @, which can be confused with native CSS keywords like @media, @import and @font-face rule.


Explain how a browser determines what elements match a CSS selector.

This part is related to the above about writing efficient CSS. Browsers match selectors from rightmost (key selector) to left. Browsers filter out elements in the DOM according to the key selector and traverse up its parent elements to determine matches. The shorter the length of the selector chain, the faster the browser can determine if that element matches the selector.

For example with this selector p span, browsers firstly find all the <span> elements and traverse up its parent all the way up to the root to find the <p> element. For a particular <span>, as soon as it finds a <p>, it knows that the <span> matches and can stop its matching.

What does * { box-sizing: border-box; } do? What are its advantages?

Make every element in the document include the padding and border in the element's inner dimensions; making it easier to reason about the layout of elements on the page.
By default, elements have box-sizing: content-box applied, and only the content size is being accounted for.
box-sizing: border-box changes how the width and height of elements are being calculated, border and padding are also being included in the calculation.
The height of an element is now calculated by the content's height + vertical padding + vertical border width.
The width of an element is now calculated by the content's width + horizontal padding + horizontal border width.
Taking into account paddings and borders as part of our box model resonates better with how designers actually imagine content in grids.

List display property in CSS?

The display property specifies the display behavior (the type of rendering box) of an element.

Example:

p.ex1 {display: none;}
p.ex2 {display: inline;}
p.ex3 {display: block;}
p.ex4 {display: inline-block;}

Is there any reason you'd want to use translate() instead of absolute positioning, or vice-versa?

translate() is a value of CSS transform. Changing transform or opacity does not trigger browser reflow or repaint but does trigger compositions; whereas changing the absolute positioning triggers reflow. transform causes the browser to create a GPU layer for the element but changing absolute positioning properties uses the CPU. Hence translate() is more efficient and will result in shorter paint times for smoother animations.

When using translate(), the element still occupies its original space (sort of like position: relative), unlike in changing the absolute positioning.

Example:

If we combine position:relative with one of the offset properties top, bottom, left or right the element will be moved from its original place in the layout whilst preserving the space in the document it once occupied. The element will be moved on to a new layer and its “layer order” or its stacking order can then be controlled with the z-index property.

.thing {
  position: relative;
  top: 100px;
  left: 50px;
}

In the above example the element will be moved 100px away from the top and 50px away from the left of its original position.

When using transform:translate(x,y) we get a very similar visual result to using relative position. The same result as above could be achieved with the following snippet:

.thing {
  transform: translate(50px, 100px);
}
In this case, we are translating the coordinates of the element by 50px along the x-axis and 100px along the y-axis. The end result is visually the same as the previous position example.

What is Accessibility (a11y) in a web application?

Accessibility refers to how software or hardware combinations are designed to make a system accessible to persons with disabilities, such as:

Visual impairment
Hearing loss
Limited dexterity
For example, a website developed with accessibility in mind might have text-to-speech capabilities or output for special braille hardware geared toward individuals with visual impairments.

What is UI/UX?

1) UI or User Interface: is how a product or website is laid out and how you interact with it: Where the buttons are, how big the fonts are, and how menus are organized are all elements of UI.

2) UX or User Experience: is how you feel about using a product or a website. So, your love for the way the new Apple Watch looks or your excitement that there’s finally a tablet-sized iPhone to watch those Corgi videos you’re obsessed with are reflections of UX. So the new look of the Facebook news feed involves a change to UI, and the way you navigate that new page is the UX.

Which property is used to change the face of a font?

The font-family property is used to change the face of a font.

 Which property is used to make a font italic or oblique?

The font-style property is used to make a font italic or oblique.

 Which property is used to create a small-caps effect?

The font-variant property is used to create a small-caps effect.

Which property is used to increase or decrease how bold or light a font appears?
The font-weight property is used to increase or decrease how bold or light a font appears.

 Which property is used to add or subtract space between the letters that make up a word?

The letter-spacing property is used to add or subtract space between the letters that make up a word.

Which property is used to add or subtract space between the words of a sentence?
The word-spacing property is used to add or subtract space between the words of a sentence.

Which property is used to indent the text of a paragraph?

The text-indent property is used to indent the text of a paragraph.

 Which property is used to align the text of a document?

The text-align property is used to align the text of a document.

Which property is used to underline, overline, and strikethrough text?

The text-decoration property is used to underline, overline, and strikethrough text.

Which property is used to capitalize text or convert text to uppercase or lowercase letters?

The text-transform property is used to capitalize text or convert text to uppercase or lowercase letters.

Which property allows you to control the shape or appearance of the marker of a list?

The list-style-type allows you to control the shape or appearance of the marker.

How do I restore the default value of a property?

The keyword initial can be used to resets it to its default value, which is defined in the CSS specification of the given property.

What is specificity? How to calculate specificity?

A process of determining which css rule will be applied to an element. It actually determines which rules will take precedence. Inline style usually wins then ID then class value (or pseudo-class or attribute selector), universal selector (*) has no specificity. ID selectors have a higher specificity than attribute selectors.

Selector Types

The following list of selector types increases by specificity:

Type selectors (e.g., h1) and pseudo-elements (e.g., ::before).
Class selectors (e.g., .example), attributes selectors (e.g., [type="radio"]) and pseudo-classes (e.g., :hover).
ID selectors (e.g., #example).

/*wins*/
a#a-02 { background-image : url(n.gif); }
a[id="a-02"] { background-image : url(n.png); }

Contextual selectors are more specific than a single element selector.The embedded style sheet is closer to the element to be styled. The last rule defined overrides any previous, conflicting rules.

p { color: red; background: yellow }
p { color: green } // wins

A class selector beats any number of element selectors.

.introduction {} //wins
html body div div h2 p {}

What do you know about CSS Transitions?

CSS Transitions allows to add an effect while changing from one style to another. You can set the which property you want to transition, duration, how you want to transit (linear, ease, ease-in, ease-out, cubic-bezier) and delay when transition will start.
CSS Transition Properties
Sl.No
Property
Description
01.
transition
A shorthand property for setting the four transition properties into a single property
02.
transition-delay
Specifies a delay (in seconds) for the transition effect
03.
transition-duration
Specifies how many seconds or milliseconds a transition effect takes to complete
04.
transition-property
Specifies the name of the CSS property the transition effect is for
05.
transition-timing-function
Specifies the speed curve of the transition effect


Example:

div {
  width: 100px;
  height: 100px;
  background: red;
  -webkit-transition: width 2s; /* Safari prior 6.1 */
  transition: width 2s;
}

What does !important mean in CSS?

It overrides the cascade and gives the style rule the highest precedence.

p {
    color: red !important;
}
#thing {
    color: green;
}
<p id="thing">Will be RED.</p>

What is CSS opacity?

The opacity CSS property sets the opacity of an element. Opacity is the degree to which content behind an element is hidden, and is the opposite of transparency.

div { background-color: yellow; }
.light {
  opacity: 0.2; /* Barely see the text over the background */
}
.medium {
  opacity: 0.5; /* See the text more clearly over the background */
}
.heavy {
  opacity: 0.9; /* See the text very clearly over the background */
}
<div class="light">You can barely see this.</div>
<div class="medium">This is easier to see.</div>
<div class="heavy">This is very easy to see.</div>

What is contextual selector?

Contextual selector addresses specific occurrence of an element. It is a string of individual selectors separated by white space (search pattern), where only the last element in the pattern is addressed providing it matches the specified contex.

It also check the context of the class in the html tree, assigning the style to the element through a specific route, taking into account the order of depth in the tree.

How is the concept of inheritance applied in CSS?

Inheritance is a concept in which the child class will inherit the properties of its parent class. It is used in CSS to define the hierarchy from the top level to the bottom level. Inherited properties can be overridden by the children class if the child uses the same name.

How do you handle browser differences in your user base?

The @supports query in CSS can be very useful to scan if the user’s current browser has a certain feature. The @supports CSS at-rule lets you specify declarations that depend on a browser's support for one or more specific CSS features. This is called a feature query. The rule may be placed at the top level of your code or nested inside any other conditional group at-rule.

@supports (display: grid) {
  div {
    display: grid;
  }
}

@supports not (display: grid) {
  div {
    float: right;
  }
}

What is Cascade?

Cascade is a method of defining the weight (importance) of individual styling rules thus allowing conflicting rules to be sorted out should such rules apply to the same selector.

P {color: white ! important} /* increased weight */
P (color: black} /* normal weight */

How Do I Have A Fixed (non-scrolling) Background Image?

In CSS, we can use the background-attachment property. The background attachment can be included in the shorthand background property, as in this example:

body {
  background: white url(example.gif) fixed ;
  color: black ;
}

Describe the following common CSS units of length: cm, em, in, mm, pc, pt, and px.

There are many ways to express units of length within CSS, but these are just some of the more common ones.

cm: centimeters
em: a relative unit of measurement based on the size of a font
in: inches
mm: millimeters
pc: pica, a unit of length equivalent to 12 points, or 1/6 of an inch
pt: 1/72 of an inch
px: a device-specific relative measurement equivalent to a certain number of pixels on a display

What are CSS vendor prefixes?

Vendor prefixes are extensions to CSS standards that can be added to these features to prevent incompatibilities from arising when the standard is extended. CSS vendor prefixes for some common platforms are listed below.

-webkit-: Android, Chrome, iOS, and Safari
-moz-: Mozilla Firefox
-ms-: Internet Explorer
-o-: Opera

CSS3 Colors

The color keyword list has been extended in the CSS3 color module to include 147 additional keyword colors (that are generally well supported), CSS3 also provides us with a number of other options: HSL, HSLA, RGBA and Opacity.

div.halfopaque {
  background-color: rgb(0, 0, 0);
  opacity: 0.5;
  color: #000000;
}
div.halfalpha {
  background-color: rgba(0, 0, 0, 0.5);
  color: #000000;
}

Rounded Corners: border-radius

border-radius: 25px;

 Drop Shadows

box-shadow: 2px 5px 0 0 rgba(72,72,72,1);

Text Shadow

text-shadow: topOffset leftOffset blurRadius color;

Linear Gradients

Syntax: background: linear-gradient(direction, color-stop1, color-stop2, ...);
/* Example */   
#grad {
  background: linear-gradient(to right, red , yellow);
}

Radial Gradients

Syntax : background: radial-gradient(shape size at position, start-color, ..., last-color);
/* Example */      
#grad {
  background: radial-gradient(red, yellow, green);
}//Default       
#grad {
  background: radial-gradient(circle, red, yellow, green);
}//Circle

What is CSS positioning?


Keyword
Value
Description
position
static
The default mode, block element is positioned in the flow. Top, left etc. are ignored.
position
relative
The block element is positioned relative to its position in the flow.
position
absolute
Block element is positioned relative to its container.
position
fixed
Block element is positioned relative to the window and won’t scroll.
top
Number [px, cm, in…]
Positions the block down from the reference point at the specified distance.
bottom
Number [px, cm, in…]
Positions the block up from the reference point at the specified distance.
left
Number [px, cm, in…]
Positions the block right from the reference point at the specified distance.
right
Number [px, cm, in…]
Positions the block left from the reference point at the specified distance.





CSS 


Explain briefly what happens when you hit a url? explain DNS lookup
​
a) DNS lookup
When we hit a url, the first thing that needs to happen is to resolve IP address associated with the domain name.
DNS(Domain name system) helps in resolving this.
DNS is like a phone book and helps us to provide the IP address that is associated with the domain name, just like our phone book gives a mobile number which is associated with the person's name.
​
b) TCP Connection
Once the IP address of the computer where the website info is there is found, a connection with it is initiated.
To communicate over the network, internet protocol is followed. TCP/IP is the most common protocol.
The connection is built using a process called 'TCP 3-way handshake'.
   1. A client computer sends a SYN (short for synchronize) message, indicating that the client wants to establish a connection.
   2. Server, if open for a new connection,responds to the client request with SYN message and Acknowledge message (ACK).
   3. The client, receives the message and acknowledges by sending an ACK message.
​
c) Communication
  After successful connection, the client/browser sends a request to the server that I want so and so. 
  The server knows what respond to send for every request, and the server responds back.
​
​
This is what happens when we hit a URL.
​
---
​
What is a URLs full form? Explain what a url is and the four parts it consists of The protocol in use The hostname of the server The location of the file The arguments to the file
​
URL stands for Uniform Resource Locator
It is a unique identifier used to locate a resource on the Interent.
It is also referred to as a web address.
​
A URL is normally made up of four parts
    1. A scheme - The scheme identifies the protocol to be used to access the resource on the Internet. It can be HTTP (without SSL) or HTTPS (with SSL) for the websites. 
    One example for other scheme is mailto: (to open a mail client)
    2. A hostname - www.example.com
    3. A path - he path identifies the specific resource in the host that the web client wants to access.   For example, /path/to/myfile.html 
    4. Parameters - The parameters are a list of key/value pairs separated with the & symbol. The web server can use those parameters to do extra stuff before returning the resource.
    For example, ?key1=value1&key2=value2
​
https://developer.mozilla.org/en-US/docs/Learn/Common_questions/What_is_a_URL#summary
​
---
​
What is HTTP protocol?
​
HTTP (Hypertext Transfer Protocol) is a protocol designed to transfer information between networked devices and runs on top of other layers of the network protocol stack. 
A typical flow over HTTP involves a client machine making a request to a server, which then sends a response message.
​
---
​
What is TCP Protocol?
​
TCP (Transmission Control Protocol) is a protocol that facilitates the transmission of packets from source to destination.
TCP lets two hosts connect and exchange data streams.
Data travels over the Internet in packets.
TCP guarantees the delivery of data and packets in the same order as they were sent. 
​
---
​
Explain all the different HTTP methods?
​
The primary or most commonly-used HTTP methods are POST, GET, PUT, PATCH, and DELETE.
These methods correspond to create, read, update, and delete (or CRUD) operations, respectively. There are a number of other methods, too, but they are utilized less frequently.
​
---
​
What are HTTP headers?
​
HTTP headers let the client and the server pass additional information with an HTTP request or response.
An HTTP header consists of its case-insensitive name followed by a colon (:), then by its value.
For example :
Authorization : Bearer <token>
​
https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers
​
---
​
What are some HTTP response codes? what does it mean
​
HTTP response status codes indicate whether a specific HTTP request has been successfully completed.
Responses are grouped in five classes :
    1. Informational responses (100-199)
    2. Successful responses (200-299)
    3. Redirection messages (300-399)
    4. Client error responses (400-499)
    5. Server error responses (500-599)
​
https://developer.mozilla.org/en-US/docs/Web/HTTP/Status
​
---
​
What does cache control on http response mean?
​
The Cache-Control HTTP header field holds instructions/directives that control caching in browsers and shared caches (e.g. Proxies, CDNs).
​
For example : 
max-age
The max-age=N response directive indicates that the response remains "fresh" until N seconds after the response is generated.
Cache-Control: max-age=604800
​
Indicates that caches can store this response and reuse it for subsequent requests while it's "fresh".
​
https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control
​
---
​
What is polling?
​
Polling is a technique by which a client can ask the server for new or fresh data by periodically making API requests to a server.
​
---
​
What is long polling?
​
In regular polling, the client makes a request to the server periodically, for example, once very 10 seconds which is not really efficient performance-wise because even if the server is not having any new/fresh data, the server is bombarded with requests.
​
So long polling offers a better way to poll the server.
The long polling flow is as follows : 
    1. The client makes a request to the server
    2. The server does not immediately respond with the requested information but waits until there's new information available.
    3. When there's new information available, the server responds with the new information.
    4. The client receives the new information and immediately sends another request to the server,re-starting the process.
​
---
​
What are web sockets?
​
Web sockets is an advanced technology that makes it possible to open a two-way interactive communication session between the user's browser/client and a server.
​
With this API, you can send messages/requests to a server and receive event-driven responses without having to poll the server for a reply.
​
https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API
​
---
​
How is web sockets different from HTTP?
​
Unlike http, where you have to constantly make requests to the server, with websockets, responses are sent immediately when they are available.
​
Web sockets keep a single, persistent connection open while eliminating latency problems that arise with HTTP request/response-based methods.
​
---
​
What is HTTPS?
​
HTTPS (HyperText Transfer Protocol Secure) is an encrypted and secure version of the HTTP protocol.
It uses SSL or TLS to encrypt all communication between a client and a server.
This secure connection allows clients to safely exchange sensitive data with a server, such as when performing banking activities or online shopping.
​
---
​
What is Cross Origin Resource Sharing? ( CORS ) Why do we need it?
​
Cross-Origin Resource Sharing (CORS) is a protocol that enables scripts running on a browser client to  interact with resources from a different origin.
This is useful because, thanks to the same-origin policy followed by XMLHttpRequest and fetch, 
JavaScript can only make calls to URLs that live on the same origin as the location where the script is running. For example, if a JavaScript app wishes to make an AJAX call to an API running on a different domain, it would be blocked from doing so thanks to the same-origin policy.
​
Most of the time, a script running in the user's browser would only ever need to access resources on the same origin (think about API calls to the same backend that served the JavaScript code in the first place). So the fact that JavaScript can't normally access resources on other origins is a good thing for security.
​
---
​
What does Access-Control-Allow-Origin header do?
​
This header specifies which origins can access the resource or whether the response can be shared with requesting code from the given origin.
​
https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Access-Control-Allow-Origin
​
---
​
What is clickjacking? How do you fix it?
​
Clickjacking is an attack that tricks a user into clicking a webpage element which is invisible or disguised as another element.
It is a type of cyber attack where an unseen malicious link is placed over a website's UI.
​
Clickjacking is caused due to allowing permission to a third party website to embed the vulnerable site using Iframe. Disallowing this can be done by setting HTTP headers that direct browser to not allow the target website to be iframed. 
This can be done by configuring server on the following two response headers: X-Frame-Options Content-Security-Policy. 
It can also be done using JavaScript code that kills the iframe. So the third solutions is: JavaScript code to burst the frame.
​
---
​
​
What are some performance metrics for your website?
​
Some of the website performance metrics are : 
​
    1. Page Speed - The time it takes for a page to load.
    2. Time to Title - The time it takes for a website's title to appear in a browser tab.
    3. Time to Start Render - The time it takes from an individual making a request and the amount of time it takes for content to begin loading — even if it does not fully load — is called the time to start render.
    4. Time to Interact - It refers to how much time it takes before individuals can begin to click on links, type in text fields, scroll on a page, and interact in other ways with a website. 
    5. DNS Lookup Speed - The time it takes for your Domain Name System (DNS) provider to translate a domain name into an IP address
    6. Bounce Rate - Refers to users "bouncing" away from your site without thoroughly searching through it.
    7. Throughput/Requests per Second - Number of requests your server receives every second.
    8. Error Rate - error rate measures the number of errors occurring at any given time, keeping track of how many occur within a specific time frame.
    9. Time to First Byte/Last Byte - 
      Time it takes for the first byte of information to reach a user’s web browser, which in this case is referred to as the time to first byte or TTFB.
      Likewise, time to last byte or TTLB refers to the moment when a user has received all of their information, and similarly, the quality of code plays a vital role in how quickly this occurs.
​
---
​
What does the following term mean?
​
   1. Time to first byte - Time to First Byte (TTFB) refers to the time between the browser requesting a page and when it receives the first byte of information from the server.
   2. Page load time - Page load time is the time it takes for a page to load
​
---
​
What do CDN or Content Delivery Networks do? When do you need a CDN?
​
CDN (Content Delivery Network) refers to a geographically distributed group of servers which work together to provide fast delivery of Internet content.
CDNs cache content like web pages, images, and video in proxy servers near to your physical location. 
​
CDNs are especially useful to large, complex websites with users spread across the globe, and websites or mobile apps with lots of dynamic content.
​
---
​
What is the difference between Client Side Renderring and Server Side Renderring?
​
In Client Side Rendering, the HTML is generated on the client side by executing Javascript code in the browser. The Javascript code is executed by the browser Javascript engine.
​
In Server Side Rendering, the HTML is generated by executing code on the server-side.
​
---
​
What is Progressive Renderring
​
Progressive rendering is the technique of sequentially rendering portions of a webpage in the server and streaming it to the client in parts without waiting for the whole page to be rendered.
​
https://medium.com/the-thinkmill/progressive-rendering-the-key-to-faster-web-ebfbbece41a4
​
---
​
What is the difference between Preloading and Prefetching resources?
​
Preload tells the browser to download and cache a resource (like a script or a stylesheet) as soon as possible. It’s helpful when you need that resource a few seconds after loading the page, and you want to speed it up.
​
Prefetch asks the browser to download and cache a resource (like, a script or a stylesheet) in the background. The download happens with a low priority, so it doesn’t interfere with more important resources. It’s helpful when you know you’ll need that resource on a subsequent page, and you want to cache it ahead of time.
​
---
​
What are service workers?
​
A service worker is a type of web worker. It's essentially a JavaScript file that runs separately from the main browser thread, intercepting network requests, caching or retrieving resources from the cache, and delivering push messages.

Explain briefly what happens when you hit a url? explain DNS lookup


How to add comments on css?
To comment in CSS, simply place your plain text inside \* */ marks. This tells the browser that they are notes and should not be rendered on the front end.
Why do we use pseudo-class?
CSS pseudo-classes are used to add special effects to some selectors.
selector:pseudo-class {
  property: value;
}
 
example:
div:hover {
  background-color: blue;
}
 
How is specificity applied?
If there are two or more CSS rules that point to the same element, the selector with the highest specificity value will “win”, and its style declaration will be applied to that HTML element.
 
 
Think of specificity as a score/rank that determines which style declaration are ultimately applied to an element.
The amount of specificity a selector has is measured using four different values (or components), which can be thought of as thousands, hundreds, tens and ones — four single digits in four columns:
1000 - Inline/Style Tag
Hundreds - One for each ID Selector
Tens - One for each class selector, attribute selector, pseudo-class contained inside the overall selector.
Ones - One for each element selector, pseudo-element contained inside the overall selector.
Note: Universal selector (*), combinators (+, >, ~, ’ ') and negation pseudo-class (:not) have no effect on specificity.
| Selector                                | Thousands | Hundreds | Tens | Ones | Total |
| --------------------------------------- | --------- | -------- | ---- | ---- | ----- |
| h1                                      | 0         | 0        | 0    | 1    | 0001  |
| h1 + p                                  | 0         | 0        | 0    | 2    | 0002  |
| h1 + p::first-letter                    | 0         | 0        | 0    | 3    | 0003  |
| li > a[href*="en-US"] > .inline-warning | 0         | 0        | 2    | 2    | 0022  |
| .class1                                 | 0         | 0        | 1    | 0    | 0010  |
| ul.class1                               | 0         | 0        | 1    | 1    | 0011  |
| #id1                                    | 0         | 1        | 0    | 0    | 0100  |
| style                                   | 1         | 0        | 0    | 0    | 1000  |
 
What method allows an element to be moved from its current position?
The translate() method moves an element from its current position (according to the parameters given for the X-axis and the Y-axis).
Take a look at this example for better understanding.
https://codepen.io/abdul-from-masai/pen/zYpRJaE
What properties does flex model have?
Properties for the parent (flex-container):
display
This defines a flex container; inline or block depending on the given value. It enables a flex context for all its direct children.
.container {
  display: flex; /* or inline-flex */
}
 
flex-direction
The flex-direction property defines in which direction the container wants to stack the flex items. Flexbox is a single-direction layout concept. Think of flex items as primarily laying out either in horizontal rows or vertical columns.
.container {
  flex-direction: row | row-reverse | column | column-reverse;
}
 
row (default): left to right
row-reverse: right to left
column: same as row but top to bottom
column-reverse: same as row-reverse but bottom to top

flex-wrap
By default, flex items will all try to fit onto one line. You can change that and allow the items to wrap as needed with this property.
.container {
  flex-wrap: nowrap | wrap | wrap-reverse;
}
 
nowrap (default): all flex items will be on one line
wrap: flex items will wrap onto multiple lines, from top to bottom.
wrap-reverse: flex items will wrap onto multiple lines from bottom to top.

flex-flow
This is a shorthand for the flex-direction and flex-wrap properties, which together define the flex container’s main and cross axes. The default value is row nowrap.
.container {
  flex-flow: column wrap;
}
 
justify-content
The justify-content property is used to align the flex items along the main axis;
.container {
  justify-content: flex-start | flex-end | center | space-between | space-around | space-evenly | start | end | left | right;
}
 
flex-start (default): items are packed toward the start of the flex-direction.
flex-end: items are packed toward the end of the flex-direction.
start: items are packed toward the start of the writing-mode direction.
end: items are packed toward the end of the writing-mode direction.
left: items are packed toward left edge of the container, unless that doesn’t make sense with the flex-direction, then it behaves like start.
right: items are packed toward right edge of the container, unless that doesn’t make sense with the flex-direction, then it behaves like end.
center: items are centered along the line
space-between: items are evenly distributed in the line; first item is on the start line, last item on the end line
space-around: items are evenly distributed in the line with equal space around them. Note that visually the spaces aren’t equal, since all the items have equal space on both sides. The first item will have one unit of space against the container edge, but two units of space between the next item because that next item has its own spacing that applies.
space-evenly: items are distributed so that the spacing between any two items (and the space to the edges) is equal.
PS : The safest values are flex-start, flex-end, and center. (as some of the properties never got support from browser)

align-items
The align-items property is used to align the flex items along the cross axis.
.container {
  align-items: stretch | flex-start | flex-end | center | baseline | first baseline | last baseline | start | end | self-start | self-end;
}
 
stretch (default): The stretch value stretches the flex items to fill the container (this is default):
flex-start / start / self-start: items are placed at the start of the cross axis.
flex-end / end / self-end: items are placed at the end of the cross axis.
center: The center value aligns the flex items in the middle of the container
baseline: items are aligned such as their baselines align

align-content
This aligns a flex container’s lines within when there is extra space in the cross-axis, similar to how justify-content aligns individual items within the main-axis.
Note : This property only takes effect on multi-line flexible containers, where flex-wrap is set to either wrap or wrap-reverse).
.container {
  align-content: flex-start | flex-end | center | space-between | space-around | space-evenly | stretch ;
}
 
flex-start :items packed to the start of the container
flex-end : items packed to the end of the container.
center : items centered in the container
space-between : items evenly distributed; the first line is at the start of the container while the last one is at the end
space-around : items evenly distributed with equal space around each line
space-evenly : items are evenly distributed with equal space around them
stretch : lines stretch to take up the remaining space

gap, row gap, column gap
The gap property explicitly controls the space between flex items. It applies that spacing only between items not on the outer edges.
.container {
  display: flex;
  ...
  gap: 10px;
  gap: 10px 20px; /* row-gap column gap */
  row-gap: 10px;
  column-gap: 20px;
}
 


Properties for the children (flex-items);
order
The order property can change the order of the flex items:
<div class="flex-container">
  <div style="order: 3">1</div>
  <div style="order: 2">2</div>
  <div style="order: 4">3</div>
  <div style="order: 1">4</div>
</div>
 
will give

flex-grow
The flex-grow property specifies how much a flex item will grow relative to the rest of the flex items.
<div class="flex-container">
  <div style="flex-grow: 1">1</div>
  <div style="flex-grow: 1">2</div>
  <div style="flex-grow: 8">3</div> // Make the third flex item grow eight times faster than the other flex items:
</div>
 

flex-shrink
The flex-shrink property specifies how much a flex item will shrink relative to the rest of the flex items.
<div class="flex-container">
  <div>1</div>
  <div>2</div>
  <div style="flex-shrink: 0">3</div> //Do not let the third flex item shrink as much as the other flex items:
  <div>4</div>
  <div>5</div>
  <div>6</div>
  <div>7</div>
  <div>8</div>
  <div>9</div>
  <div>10</div>
</div>
 
will give

flex-basis
The flex-basis property specifies the initial length of a flex item before the remaining space is distributed.
<div class="flex-container">
  <div>1</div>
  <div>2</div>
  <div style="flex-basis: 200px">3</div> // Set the initial length of the third flex item to 200 pixels:
  <div>4</div>
</div>
 
will give

flex
The flex property is a shorthand property for the flex-grow, flex-shrink, and flex-basis properties.
<div class="flex-container">
  <div>1</div>
  <div>2</div>
  <div style="flex: 0 0 200px">3</div> // Make the third flex item not growable (0), not shrinkable (0), and with an initial length of 200 pixels:
  <div>4</div>
</div>
 
align-self
The align-self property specifies the alignment for the selected item inside the flexible container.
The align-self property overrides the default alignment set by the container’s align-items property.
<html>
<head>
<style>
.flex-container {
  display: flex;
  height: 200px;
  background-color: #f1f1f1;
}

.flex-container > div {
  background-color: DodgerBlue;
  color: white;
  width: 100px;
  margin: 10px;
  text-align: center;
  line-height: 75px;
  font-size: 30px;
}
</style>
</head>
<body>

<div class="flex-container">
  <div>1</div>
  <div>2</div>
  <div style="align-self: center">3</div>
  <div>4</div>
</div>

</body>
</html>
 
will give the following

What is the difference between flex and grids?
Grid is made for two-dimensional layout while Flexbox is for one. This means Flexbox can work on either row or columns at a time, but Grids can work on both.
Major Uniqueness between Flexbox and Grids is that the former works on content while the latter is based on the layout.
CSS Grids helps you create the outer layout of the webpage. You can build complex as well responsive design with this. This is why it is called ‘layout first’. Flexbox mostly helps align content & move blocks.
Give an example where we have to use grids and where you have to use flexbox?
CSS Grids helps you create the outer layout of the webpage. You can build complex as well responsive design with this. This is why it is called ‘layout first’. While flexbox mostly helps align content & move blocks.
CSS grids are for 2D layouts. It works with both rows and columns.Flexbox works better in one dimension only (either rows OR columns).
You should consider flexbox when :
You have a small design to implement
You need to align elements
You need a content-first design
You should consider CSS grid when :
You have a complex design to implement
You need to have a gap between block elements
You need to overlap elements
You need a layout-first design
In simple terms
 
 
“CSS grid is for layout, Flexbox is for alignment”
Give an example where you cannot use flexbox, and you can only use grids?
Grid is usually used to make a more complex layout. You can build complex as well responsive design with this. It works with both rows and columns.Flexbox works better in one dimension only (either rows OR columns).
Now take a look at this example;
https://codepen.io/abdul-from-masai/pen/KKZQYgw
If you have some complex layout as this wherein you want to layout in different ways basis the screen size; You’d rather use CSS grid over flex;
for a simple one dimensional layout flexbox can be useful to help align content
What are combinators? give examples of how you can use them
Combinators lets you combine two or more selectors so you can be more specific in your selection method. There are different types of combinators.
.
,
+
~
>
space
 
Type & Class (.)
elemtype.class { style properties }
 
<div>This is the first div</div>
<div class="class1">This is the second div</div>
<div class="class2">This is the third div</div>
<p>This is the first paragraph</p>
<p class="class1">This is the second paragraph</p>
<p class="class2">This is the third paragraph</p>
 
/* All <div> elements */
div {
  color: red;
}

/_ All elements with class="class1" _/
.class1 {
color: green;
}

/_ All <p> elements with class="class2" _/
p.class2 {
color: violet;
}
 
Ref : https://codepen.io/nrupuld/pen/zVweGK
Multiple Selectors, Same Properties (,)
The comma in a CSS selector separates multiple selectors within the same styles.
selector1, selector2 { style properties }
 
div, p {
  padding: 10px;
  font-size: 20px;
  margin: 0;
}
 
Ref : https://codepen.io/nrupuld/pen/xopQEZ
Adjacent Sibling Selector (+)
The adjacent sibling combinator (+) separates two selectors and matches the second element only if it immediately follows the first element, and both are children of the same parent element.
former_element + target_element { style properties }
 
Ref : https://codepen.io/nrupuld/pen/XLVyzm
General Sibling Selector (~)
The general sibling combinator (~) separates two selectors and matches the second element only if it follows the first element (though not necessarily immediately), and both are children of the same parent
former_element ~ target_element { style properties }
 
Ref : https://codepen.io/nrupuld/pen/pXpQLM
Child Combinator (>)
The child combinator (>) is placed between two CSS selectors. It matches only those elements matched by the second selector that are the children of elements matched by the first.
selector1 > selector2 { style properties }
 
Ref : https://codepen.io/nrupuld/pen/rEpQRL
Descendant Combinator ( )
The descendant combinator typically represented by a single space ( ) character combines two selectors such that elements matched by the second selector are selected if they have an ancestor element matching the first selector.
selector1 selector2 { style properties }
 
Ref : https://codepen.io/nrupuld/pen/Oezaed
What does object-fit do?
The CSS object-fit property is used to specify how an <img> or <video> should be resized to fit its container.
This property tells the content to fill the container in a variety of ways; such as “preserve that aspect ratio” or “stretch up and take up as much space as possible”.
You can read more about it here.
https://developer.mozilla.org/en-US/docs/Web/CSS/object-fit
 
 
https://www.w3schools.com/css/css3_object-fit.asp
What does rotate do?
The transform property applies a 2D or 3D transformation to an element. This property allows you to rotate, scale, move, skew, etc., elements.
rotate(angle) // Defines a 2D rotation, the angle is specified in the parameter
 
You can give it a try here : Defines a 2D rotation, the angle is specified in the parameter
For More Info Ref : https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/rotate
What rule can be used to define animations
The @keyframes rule specifies the animation code.
The animation is created by gradually changing from one set of CSS styles to another.
During the animation, you can change the set of CSS styles many times.
Specify when the style change will happen in percent, or with the keywords “from” and “to”, which is the same as 0% and 100%. 0% is the beginning of the animation, 100% is when the animation is complete.
Syntax :
@keyframes animationname {keyframes-selector {css-styles;}}
 
Take a look at following example.
For More info :
 
 
https://www.w3schools.com/cssref/css3_pr_animation-keyframes.asp
 
 
https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Animations/Using_CSS_animations
When working with attribute selectors, how can you select elements which contain a particular attribute value?
a[href*="en-US"] // selects an `a` tag which a particular href attribute value that has been asked
 
What does @media do?
The @media rule is used in media queries to apply different styles for different media types/devices.
Media queries can be used to check many things, such as:
width and height of the viewport
width and height of the device
orientation (is the tablet/phone in landscape or portrait mode?)
resolution
Using media queries are a popular technique for delivering a tailored style sheet (responsive web design) to desktops, laptops, tablets, and mobile phones.
You can also use media queries to specify that certain styles are only for printed documents or for screen readers (mediatype: print, screen, or speech).
In addition to media types, there are also media features. Media features provide more specific details to media queries, by allowing to test for a specific feature of the user agent or display device. For example, you can apply styles to only those screens that are greater, or smaller, than a certain width.
syntax :
body {
  background-color: lightblue;
}

@media screen and (min-width: 400px) {
  body {
    background-color: lightgreen;
  }
}

@media screen and (min-width: 800px) {
  body {
    background-color: lavender;
  }
}
 
What can be used to override properties of an element
To override the CSS properties of a class using another class, we can use the !important directive. In CSS, !important means “this is important”, and the property:value pair that has this directive is always applied even if the other element has higher specificity.
Syntax :
element1 {
    property-x: value_y  !important; /* This will be applied. */
}
element2 {
    property-x: value_z; /* This will not be applied. */
}
 
html :
 <p class="my_fav_font my_para">Cascading Style Sheets,fondly referred to as CSS, is a..</p>

css :
.my_fav_font {
  font-family: 'Indie Flower', cursive !important;
  /* This will be applied. */
}

.my_para {
  font-family: 'Mansalva', cursive;
  /* This will not be applied. */
  text-align: justify;
  background-color: powderblue;
  font-size: 130%;
}
 
How can you select every alternate elements in a list of elements using css?
Syntax :
HTML
<ul>
  <li>1</li>
  <li>2</li>
  <li>3</li>
  <li>4</li>
  <li>5</li>
  <li>6</li>
  <li>7</li>
  <li>8</li>
  <li>9</li>
  <li>10</li>
</ul>
 
CSS
ul{
  list-style-type: none;
  color: white;
}
li:nth-of-type(odd){ // or you can also use li:nth-child(odd)
  background-color:blue;
}
li:nth-of-type(even){
  background-color:red;
}
 
What is the ranking of selectors with respect to specificity
Ranking from Low To High
universal_selector, combinators selector, negation pseudo-class (:not) selector ( these selectors have no effects on specificity )
element selector, pseudo element selector
class selector, attribute selector, pseudo-class contained inside the overall selector
id selector
inline styling
How can we apply same styles to multiple selectors?
To group CSS selectors in a style sheet, use commas to separate multiple grouped selectors in the style. In this example, the style affects the p and div elements:
div, p { color: #f00; }
 
What are the differences between relative and absolute in CSS?
Relative
Absolute
An element with position: relative; is positioned relative to its normal position.
An element with position: absolute; is positioned relative to the nearest positioned ancestor. However; if an absolute positioned element has no positioned ancestors, it uses the document body, and moves along with page scrolling.
Setting the top, right, bottom, and left properties of a relatively-positioned element will cause it to be adjusted away from its normal position. Other content will not be adjusted to fit into any gap left by the element.
Absolute positioned elements are removed from the normal flow, and can overlap elements.
example : https://www.w3schools.com/css/tryit.asp?filename=trycss_position_relative
example: https://www.w3schools.com/css/tryit.asp?filename=trycss_position_absolute


What is hoisting?
It is JavaScript’s default behavior of moving all declarations to the top of the current scope (to the top of the current script or the current function).
So in javascript where you can access a variable or a function even before you have initialised it.
var x = 7; 

function sayHello(){
 console.log("Hello") 
}

console.log(x); // gives 7
sayHello(); // "Hello"
 
Pretty standard stuff . But when you do below stuff
console.log(x); // undefined
sayHello(); // "Hello"

var x = 7; 

function sayHello(){
 console.log("Hello") 
}
 
This is because of that same execution concept… Where in memory allocation phase
x : undefined
sayHello : function sayHello(){ ... }
 
memory is allocated to variable x and function sayHello even before the thread of execution phase starts. hence we get these values
Now memory is allocated to x even though it is not initialised in the memory allocation phase itself. There x was given a placeholder undefined value.
But if x variable isn’t present anywhere; Let’s say the code look something like this
console.log(x); // it will throw a reference error saying `x` is not defined
sayHello(); // "Hello"

function sayHello(){
 console.log("Hello") 
}
 
because in memory allocation phase. there wasn’t any memory allocated to x… so the code doesn’t know what x is and hence the error.

Let’s take another example
console.log(x); // undefined
sayHello(); // Uncaught TypeError: sayHello is not a function

var x = 7; 

var sayHello = () => {
 console.log("Hello") 
}
 
Here in memory allocation phase. It treats sayHello as a variable and not as a function and hence gives it value undefined .
So when the thread of execution starts --> Since it is undefined and you are trying to invoke it… It throws this error

Let’s take another example
console.log(x); // undefined
sayHello(); // Uncaught TypeError: sayHello is not a function

var x = 7; 

var sayHello = function(){
 console.log("Hello")
}
 
Here as well, In memory allocation phase, it would still behave as a variable. and hence the same result.

What is scoping?
Scope refers to the current context of execution.
If a variable declaration is inside a function, then it is said that the variable is defined with function local scope in that function.
So this variable is accesible in that function, and any of its nested functions.
Otherwise it has a global scope ie. they are members of the global object.
If a variable or other expression is not “in the current scope,” then it is unavailable for use.
Scopes can also be layered in a hierarchy, so that child scopes have access to parent scopes, but not vice versa.
Example:
function a(){
  console.log(b); /* at this point, javascript tries to find b in local scope; when it wasn't able to find b in local scope, it tries looking for b in parent scope and hence prints 10; */
}
var b = 10;
a();

 

How are var, let const different?
let follows a block scope. var doesnt follow block scope.
If var is used inside a for loop, it is still accessible outside it.
let throws a Reference error when accessing the variable outside of a for loop or any block scope (written inside { … } )
let also throws an error when you try to access a variable before its declared
let throws an error when you redeclare a variable
const is the same as let, except it needs a value to be assigned while declaring, and does not allow reassigning values to a variable.

What are the two main differences in arrow functions?
Arrow functions don’t have their own binding to “this” and should not be used as methods.
Arrow functions aren’t suitable for call,apply and bind methods.

Does Call apply bind work for arrow functions?
No.
The call, apply and bind methods are NOT suitable as arrow functions – as they were designed to allow methods to execute within different scopes – because arrow functions establish this based on the scope the arrow function is defined within.

What does Call Apply Bind do?
All javascript functions have access to some very special methods which we can use to control where this should refer. Such methods are call(), apply(), bind()
What if you want to access a method of one object onto another?
Remember, 'this' denotes owner object. If we change where 'this' points, we can change owner object, allowing us to access a value of a different object.
Call()
call() provides a new value of this to the function/method
Understand how to access Method of another object
Its like a person in bedroom wants to access a dish from kitchen without going to kitchen, well only a superpower can make it happen.
In second example, createAadharId() can be a big function. Not a good idea to add it on every object, so we borrow it for a while using .call, .apply or .bind
similarly, there is no normal way in Js for us to access Method of another object
we need a superpower and that is call method.
const kitchen = {
  name: "kitchen",
  purpose: "cook",
  cookFood() {
    console.log(`Serving ${this.order} in 2 mins`);
  },
};

const bedroom = {
  name: "bedroom",
  purpose: "sleep",
  order: "magiee",
};

kitchen.cookFood.call(bedroom);
 
var person1 = {
  name: "jonny kumar",
  createAadharId() {
    this.id = Math.round(Math.random() * 100000000000000);
  },
};

var person2 = { name: "happy singh" };

person1.createAadharId.call(person2);
 
Try and visualize the above code using https://pythontutor.com/javascript.html#mode=edit
Apply()
The apply() method is literally the same as call() method.
They just both take arguments differently.
call() takes individual arguments separated by comma.
printBio.call(obj,20,'Pune')
apply() takes a single array of arguments.
printBio.apply(obj, [20, 'Mumbai'])
Bind()
You can bind a particular object as this to a function and use it later
You cannot use call() or apply() later, they run immediately.
var pokemon = {
    firstname: 'Pika',
    lastname: 'Chu ',
    getPokeName: function() {
        var fullname = this.firstname + ' ' + this.lastname;
        return fullname;
    }
};

var pokemonName = function() {
    console.log(this.getPokeName() + 'I choose you!');
};

var logPokemon = pokemonName.bind(pokemon); // creates new object and binds pokemon. 'this' of pokemon === pokemon now

logPokemon(); // 'Pika Chu I choose you!

 
All Call, Apply and Bind do the exact same thing. The only difference is Apply takes only one argument as an array while bind doesnt executes itself right away, it just binds the new ‘this’ value.

What are closures?
Closures : Function bundled with its lexical environment is known as a closure. Whenever function is returned, even if its vanished in execution context but still it remembers the reference it was pointing to. Its not just that function alone it returns but the entire closure and that’s where it becomes interesting.
function x() {
  var a = 7;
  function y() {
    console.log(a); // if we put a debugger here; We would get to see Closure(x) space in chrome browser 
  }
  y();
}

x();
 
Now comes the interesting part
function x() {
  var a = 7;
  function y() {
    console.log(a);
  }
  return y;
}

var z = x(); // now we know at this point of time; x is completely out of Execution Context callstack meaning x is completely gone

// ....Thousands of lines of code.
// ....
// ....
// ....
console.log(z())// prints 7 // but still we are able to access variable "a" which is inside x at this point. 


// and the reason is closure. 
// functions when they are returned from another function. they still maintain their lexical scope. hence "function y" remembers where this "a" variable came from. 
// basically when y was returned from x invocation. It returned entire closure (function y and it's lexical scope as well ). 
 
The above function can also be written as
function x() {
  var a = 7;
  return function y() {
    console.log(a);
  }
}

var z = x();

// ....Thousands of lines of code.
// ....
// ....
// ....
console.log(z());
 

Few Edge Cases :
case1 :
function x() {
  var a = 7;
  function y() {
    console.log(a);
  }
  a = 100;
  return y;
}

var z = x();

// ....Thousands of lines of code.
// ....
// ....
// ....
z(); // This returns 100; 
// when we returned y it came with it's lexical scope. Here a's reference is 100 in lexical scope. hence it prints 100. 
 
case2 :
function z() {
  var b = 200;
  function x() {
    var a = 7;
    function y() {
      console.log(a, b); // prints 7,200
// also when we check this using chrome source tool --> you get to see closure(y) and closure(x) as well
    }
    y();
  }
  x();
}
z();

// basically y forms a closure along with scope of x and z function.
 
Few Common Uses for closures :
Module Design Pattern
Currying
HOF Functions like once
memoize
Data hiding and encapsulation
maintaining state in async world
setTimeouts
Iterators
and many more…
Data hiding and Encapsulation example :
function counter() {
  var count = 0;
  return function increment() {
    count++;
    console.log(count);
  };
}

var counter1 = counter();
counter1();
counter1();

var counter2 = counter();
counter2();
counter2();
counter2();
counter2();
counter2();

// This way we can make sure that var count is private and no part of code outside of function counter(){} can manipulate it.
 

Write a program to debounce a search bar?
One practical example wherein debouncing is used is you open a flipkart app and the search bar there. everytime you pause in the search bar while typing. an API call is made to the network and we get suggestions in accordance with that there.
This is one of the example wherein debounce method is applied. there are many examples wherein debounce method is applied.
Making API call on scroll event
When we try to implement lazy loading
Window resize
Debounce Method takes in a function and returns you a function which is way better than your function and optimizes performance of your app
Codepen Link for the below code : https://codepen.io/abduljabbarpeer/pen/OJONQem
index.html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Debouncing</title>
</head>
<body>
  
  <input type="text" onkeyup="betterFunction()"/>
  <script src="index.js"></script>
</body>
</html>
 
index.js
let counter = 0;

const getData = () =>{
  //01. calls an API and gets Data
  console.log("Fetching Data...",counter++) // 02 . when we do this; an API call is made on every keystroke
  // 03. for example if i typed "joey" in the input box; API call is made 4 times
  // 04. but our aim is to create a function which makes API call only when user pause for a moment.
}

const debounce = function (fn,delay) {
  let timer;
  return function(){
    let context = this, // 11. these are required things to keep a check that the environment of lexical scope where this
    args = arguments;   // function is running is correct and same getData method is called with same arguements if it had.
    
    // 12. what if a keystroke occurs in between those 300ms; then we have to stop calling this getData method. 
    //Hence we need to clear this timeout. and to clear timeout. 
    
    // 13. keystroke --> betterFunction --> debounce --> anonymous function --> setTimeout(300ms) --> getData
    
    // 14. So a new function call is made in every keystroke(that is established)
    
    // 15. Whenever a new function call is made before 300ms has passed. we'll clear that timer
    
    clearTimeout(timer) 
    timer =  setTimeout(()=>{ 
      fn.apply(context,args)     
    },delay)

    // 16. this way we can make sure that network request is made only when user pauses for 300ms after last keystroke;
    // setTimeout() is started and if user types before that; we'll clear that timeout
  }
}

//05. so we create a function called `betterFunction` which has method called debounce which takes in another
// our function `getData` as paramter and we'll write millisecs as the second paramter

//06. What it basically does is it calls getData function after those many millisecs

const betterFunction = debounce(getData,300);
// 07. when debounce is called with getData and 300 as arguements; it returns function `betterFunction` 
// 08. so on keyup in input box we call `betterFunction` instead of calling `getData()`.
// 09. debounce takes in a function (in this case getData) and a delay as parameter and returns a function.


// 10. this setTimeout waits for the delay time (in this case 300ms) and checks if there is any more
// keystroke to listen to in this time. only then getData is invoked


// 17 . what `debounce` does above is called debouncing. It takes in a function and a delay as arguements 
// and does not allow the function it took as an argument to make unnecessary request calls and will only 
//  allow if the difference between time interval between two function calls is greater than the delay
 

Write a program to throttle a search bar?
It is performance optimisation technique which limits the number of function calls made.
How does Throttling works ?
let’s say there is a button which makes a function call on every click and we want to limit the number of function calls made
So That’s where Throttling comes into picture .
Assume | as a click event and we want function call every 300ms
|-->FC | | | | | | (300 ms is passed over here) |--> FC | | | | | (300 ms is passed over here) |-->FC | | | | | | | |
 
In this way; we can limit the rate of function calls using throttling.
Example :
function expensive(){
  console.log("expensive function is called")
}

window.addEventListener("resize",expensive)
 
When we call expensive on every resize; When a user starts resizing; Hundreds and thousands events are triggered and those many times expensive functions are called which is not really good performance wise.
So we need to have a better function which we can call on resize event that could reduce the number of function calls made
const betterExpensive = throttle(expensive,delay)
 
Let’s Jump into code for better explanation
Codepen Link : https://codepen.io/abduljabbarpeer/pen/zYPqWMv
let counter = 0

// 01. We have an expensive function which is being called by default on every resize;
// 02. We don't want that and we want to enhance performance of our app (As hundreds of Function calls are made on every resize event which is not good performance wise)

const expensive = () =>{
  counter++
  console.log("Expensive Function",counter)
}


const throttle = (func,delay) =>{ // 05. We know throttle takes in a function and delay and returns a function

  let flag = true //

  return function(){  // 06. The function being returned

    let context = this; // 07.  to maintain lexical scoping; basically referring that the this refers to expensive function
    let args = arguments;

    // 08. Every time a function call is made; we are gonna make a flag which stores the info regarding time
    // and which makes sure the delay time has passed before another function call is made

    // 09. this flag is using the concept of closure to store the boolean (This closure does not allow me inside if condition if it's value is still false and not set to true which happens after timeout)

    if(flag){
      func.call(context,...args) // 10. When function call is made
      flag = false // 11. we set the flag to false (To make sure function calls are not made again)

      setTimeout(()=>{ // 12. After the delay of 1000ms in this case; value is again set to true (Now function calls can be made)
        flag = true
      },delay)
    }
  }
}

const betterExpensive = throttle(expensive,1000)

// 03. So we write betterExpensive function which takes in expensive function and delay-interval and executes function call
// after that interval

window.addEventListener('resize',betterExpensive)

// 04. this betterExpensive function is called on every resize now
 

create a custom method for an array called myMap, use prototype chain to achieve this
const arr = [1,2,3]
arr.myMap(a=>a*5)
[ 5, 10, 15 ]
 
let arr = new Array(1,3,5)

Array.prototype.myMap = function(callback){
  let newarr = new Array()
  for(let i=0; i<arr.length; i++){
      newarr.push(callback(arr[i], i, arr))
  }
  return newarr;
}

let result = arr.myMap(ele => ele+12)

console.log(result)
 

What is event bubbling?
Event bubbling
Events in DOM have a bubbling effect. Like how bubbles are move up in water or soda, so do events.
When an event occurs, the event.target refers to the element that initiated the particular event. Ths event can bubble up and move along the DOM upto the window node.
During this phase only non capturers in the path from the event target to the window node is called.
note:
Not all events have the property to bubble up
Working with the propogated information
event.target references to the event target
event.currentTarget references to the node on which the listener which is running is registered on.
Example 1
https://codepen.io/albseb511/pen/rNVzWbO
Example 2
https://codepen.io/SitePoint/pen/jmXdpz

What is event loop?
Browser attaches all the Web APIs to global space/object (window object) and this gives them access to execution stack;
Some of the common Web APIs are DOM API, fetch API, web storage APIs (like local storage etc), setTimeout etc
example 1
Now let’s try and understand event loops with this example;
console.log("Before setTimeout")

setTimeout(function printHello(){
  console.log("hello")
},5000)

console.log("After setTimeout")
 
when we start executing the above code; The Global Execution Context gets inside the execution stack. After memory allocation phase; Code execution phase starts and prints “Before setTimeout” to console
When the browser sees setTimeout it registers the callback (printHello) that has been passed inside this setTimeout function and also note down the delay time. timer starts in browser
The execution context moves to next line and prints “After setTimeout”
Once we reach the end of code. The Global Execution Context gets popped off from the execution stack.
Now Once the timer expires, this callback function printHello(){} needs to go to the execution stack
But this can’t be directly go to execution stack. It’ll go to the execution stack through Callback Queue
Now this is where Event Loops come into picture. The job of the Event Loop is to check Callback Queue and Execution Stack and if there exists any callback function inside Callback Queue and if Execution Stack is Empty. If callback function inside Callback Queue exists and if execution stack is empty, It puts the callback function inside Callback Queue into Execution Stack.
You can simulate the same using http://latentflip.com/loupe/
Take a look at this video for better understanding : https://drive.google.com/file/d/1K8Dc7BzX8LrdjUSAtzfY2M3pW1HMr-Ej/view?usp=sharing
example 2
Now let’s try DOM API;
console.log("Before DOM API")

document.getElementById('btn').addEventListener('click', function printHello(){
  console.log("Hello")
})

console.log("After DOM API")
 
when we start executing the above code; The Global Execution Context gets inside the execution stack. After memory allocation phase; Code execution phase starts and prints “Before DOM API” to console
document.getElement... is basically a DOM API which fetches something from DOM. and addEventListener registers a callback printHello on an click event and moves on
then we move to next line which prints “After DOM API” .
Global Execution Context gets popped off the execution context.
but still the registered callback function printHello(){} stays until and unless we explicitly remove it using removeEventListener or close the browser
When the event click happens ( basically user clicked the button ). then the printHello(){} function moves to the callback event queue and waits for it’s turn to get executed.
Now the job of event loop is to monitor execution stack and callback queue and if execution stack is empty and if there exists function in callback queue; It removed the function from the callback queue and pushes it to execution stack.
example 3
Now let’s try fetch API;
console.log("Before Fetch and setTimeout");

setTimeout(function printHello() {
  console.log("hello");
}, 5000);

fetch(`https://reqres.in/api/users?page=2`)
  .then((res) => res.json())
  .then((res) => console.log(res))
  .catch((err) => console.log(err));

console.log("After Fetch and setTimeout");
 
when we start executing the above code; The Global Execution Context gets inside the execution stack. After memory allocation phase; Code execution phase starts and prints “Before Fetch and setTimeout” to console
setTimeout registers callback function printHello in browser environment and timer starts
fetch registers a callback function to be executed once data is fetched from the server
Now there are two kinds of queues; one being callback queue and the other being microtask queue.
the callback of fetch once it fetches data back from server and is ready to push the callback into the queue goes to Microtask Queue instead of Callback Queue.
the callback of setTimeout goes to Callback Queue.
The difference between Microtask Queue and Callback Queue is event loop gives precedence to Microtask Queue over Callback Queue
So once the Global Execution Context gets popped off from execution context and the Execution context is empty; Event Loop looks at Microtask Queue and Callback Queue and gives preference to Microtask Queue and removes the callback(fetch) from Microtask Queue and pushed to execution stack.
printHello is removed from Callback Queue and moved to execution stack.

Explain promises to a 5 year old, with simple examples
Promises are Commitment by someone to do or not to do something;
Now let’s take an example;
function appendScript(externalScript) {
  let script = document.createElement("script");

  script.src = externalScript;

  document.head.append(script);

  /*
    1. here we are trying to load an external script and then invoke a function hello from that script;
  */

  hello(); // 2. this particular function is dependant on script to get completely loaded --> dependant on some other piece of code; --> this is where promises come in
}

appendScript("/myscript.js");
 
basically in the above case the script should give us a promise that when i am done loading --> you can load ‘myscript.js’ and execute the function;
Now let’s understand Why Promises ??
Sometimes a piece of code will take ‘x’ seconds to execute.
Depending on the it, we have other piece of code.

This other piece of code is dependent on first piece of code. So, it waits until first piece of code is done executing
 
basically we want some mechanism where we want some signal that in above case for example that we get a signal to invoke this function hello();
Promises have consequences.
They will be fullfilled.
They will not be fullfilled.
They will be in the process.
Promise by nature, takes time to fulfill or not fulfill.
Basically, we have to WAIT.
In JS programming, We need asynchronous behaviour.
Promises are useful when we have to wait for return value and use that return value without interrupting anything else in our program.
Promise is an object ( constructor object )
var myPromise = new Promise(function (resolve, reject) {
  resolve(`successful`);

  reject(`got rejected`);
});

console.log(`myPromise : `, myPromise); //if resolved --> Promise {<fulfilled>: 'successful'}
console.log(`myPromise : `, myPromise); //if rejected --> Promise {<rejected>: 'got rejected'}
 
modifications to the above code;
function appendScript(s) {
  return new Promise(function (resolve, reject) {
    let script = document.createElement("script");

    script.src = s;

    document.head.append(script);
    script.onload = function () {
      resolve(`Script loading done...`);
    };

    script.onerror = function () {
      reject(`Script loading failed`);
    };
  });
}

appendScript("./myScript.js")
  .then(function (res) {
    console.log(res);
    hello() // invoke function only when script is loaded
  })
  .catch(function (err) {
    console.log(err);
  });
 
Syntax for promises;
myPromise.then(function (res) {
  // do something when promise is successful
})

myPromise.catch(function (err) {
  // do something when promise is a unsuccessfull
})
 
Now for the sake of explanation; we’ve tried to simplify; But if you are looking for official documentation. we’d recommend go through https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise

Write a function called sleep that will return a promise, if you do not provide a number to the function, then it will return an error and goto the catch block
function sleep(timer){
  return new Promise(function(resolve,reject){
    if(timer && typeof timer==='number'){
      setTimeout(()=>{
        resolve(`slept for ${timer} milli seconds`)
      },timer)
    }
    else{
      reject(`Timer value is missing..`)
    }
  })
}
 

what does async await mean?
An async function is a function declared with the async keyword, and the await keyword is permitted within it. The async and await keywords enable asynchronous, promise-based behavior to be written in a cleaner style, avoiding the need to explicitly configure promise chains.
basically async await are new and better way of writing promises;
Let’s rewrite the above example given for promises with async and await; That should give you a better idea.
function appendScript(s) {
  return new Promise(function (resolve, reject) {
    let script = document.createElement("script");

    script.src = s;

    document.head.append(script);
    script.onload = function () {
      resolve(`Script loading done...`);
    };

    script.onerror = function () {
      reject(`Script loading failed`);
    };
  });
}

async function initFunction() {
  try {
    let res = await appendScript("./myScript.js");
    console.log(res);
    hello();
  } catch (error) {
    console.log(error);
  }
}

initFunction();
 
For more info : https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise

What does the this keyword mean?
In JavaScript, the this keyword refers to an object.
Which object depends on how this is being invoked (used or called).
The this keyword refers to different objects depending on how it is used:
In an object method, this refers to the object.
let name = {
firstname : "John",
lastname : "Doe",
printFullName : function(){
    console.log(this.firstname+ " "+ this.lastname)
  }
}


Alone, this refers to the global object.
let x = this;
x // window object


In strict mode, when used alone, this also refers to the global object:
let x = this;
x // window object


In a function, this refers to the global object.
function myFunction() {
  return this;
}
console.log(myFunction());


In a function, in strict mode, this is undefined.
"use strict";

function myFunction() {
  return this;
}
console.log(myFunction());


In an event, this refers to the element that received the event.
<button onclick="this.style.display='none'">
Click to Remove Me!
</button>


Methods like call(), apply(), and bind() can refer this to any object.
CALL: call() provides a new value of ‘this’ to the function/method.
example:
 var person1 = {
    name: "John",
  };

  var person2 = {
    name: "Jill",
  };

  function myName(age,city) {
    this.age = age;
    this.city = city;
  }
  myName.call(person1, 28, "bangalore");


APPLY:The apply() method is literally the same as call() method.They just both take arguments differently.
example:
 var person1 = {
    name: "John",
  };

  var person2 = {
    name: "Jill",
  };

  function myName(age,city) {
    this.age = age;
    this.city = city;
  }
  myName.apply(person1, [28, "bangalore"]);


BIND: You can bind a particular object as ‘this’ to a function and use it later.You cannot use call() or apply() later, they run immediately.
example:
 var person1 = {
    name: "John",
  };

  var person2 = {
    name: "Jill",
  };

  function myName(age,city) {
    this.age = age;
    this.city = city;
  }
  let myBindFunc = myName.bind(person1, 28, "bangalore");

  myBindFunc();



What is currying?
It is an advance technique of working with functions, transformation of the function of multiple arguments into several functions of a single argument in sequence.
for example, currying is a transformation of functions that translates a function from callable as f(a, b, c) into callable as f(a)(b)©
There are two ways in which function currying can be done.
Using bind method
Using closures concept
Using bind method
Generally we write a function like this. Plain and simple.
function multiply(x,y){
  console.log(x*y)
}

multiply(5,3)
 
Now let’s create one more function mulByFive . This is how we do function currying using bind method.
function multiply(x,y){
  console.log(x*y)
}

var mulByFive = multiply.bind(this,5) // this will essentially create a copy of multiply method. this refers to multiply
// function and we pass in few arguements

mulByFive(4) // 5 * 4 = 20 ( x=5 and y = 4)
 
This is basically equal to
function mulByFive(y){
  let x = 5;
  console.log(x*y)
}
 
When we pass in two arguments after bind like this
var multiply = function (x,y){
  console.log(x*y)
}

var mulByFive = multiply.bind(this,5,3)

mulByFive(4) // This will essentially give 5 * 3 = 15 ( x = 5 and y = 3 ) and 4 gets ignored
 
This is basically how we do currying using bind method. We make a copy of multiply method and we make more methods by pre-setting some arguments inside the function. like the way we preset 5 in
var mulByFive = multiply.bind(this,5)
mulByFive(3) // 5 * 3 = 15
 
Using Closures
Function currying can be achieved easily through closures in this manner

var multiply = function (x){
  return function(y){
    console.log(x*y)
  }
}
var mulByFive = multiply(5)
mulByFive(8) // 5 * 8 = 40 (since variable 5 is stored as closure property inside mulByFive function)

 

Write a program to flatten an array
// input: [ 1, [ 2, 3 ], [ 3 ], [ [ [ 5]],  6]  ]
// output => [ 1, 2, 3, 3, 5, 6 ]
 
let input = [1, [2, 3], [3], [[[5]], 6]];

const flatten = (arr) => {
  return arr.reduce((acc, curr) => {
    if (Array.isArray(curr)) {
      return acc.concat(flatten(curr));
    }
    return acc.concat(curr);
  }, []);
};

let output = input.reduce((acc, curr) => {
  return acc.concat(Array.isArray(curr) ? flatten(curr) : curr);
}, []);

console.log(output);
 
or there is a new Array flat method that can be used to solve this.
let output = [[[[[0]], [1]], [[[2], [3]]], [[4], [5]]]].flat().flat(Infinity)

console.log(output) // [0,1,2,3,4,5]
 
Read more : https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flat

What are classes? what are getters and setters?
Classes were introduced in ES6 or ECMAScript 2015. Classes are used to basically create templates which can be used later on to create objects instances.
The Constructor method inside the classes allows us to initialise the values of instances as we had done before the ES6 was introduced with the help of functions.
Getters and setters are basically used to define methods in a class in such way that they can then be used as properties.
Now let’s take an example ; Say you have a class Person which has name property; and you want to manipulate the name property only via pair of methods.
class Person {
    constructor(name) {
        this.setName(name);
    }
    getName() {
        return this.name;
    }
    setName(newName) {
        newName = newName.trim();
        if (newName === '') {
            throw 'The name cannot be empty';
        }
        this.name = newName;
    }
}

let person = new Person('John Winchester');
console.log(person); // John Winchester

person.setName('Harry Potter');
console.log(person.getName()); // Harry Potter
 
The getName() and setName() methods are known as getter and setter in other programming languages such as Java and C++.
ES6 provides specific syntax for defining the getter and setter using the get and set keywords. For example:
class Person {
    constructor(name) {
        this.name = name;
    }
    get name() {
        return this._name;
    }
    set name(newName) {
        newName = newName.trim();
        if (newName === '') {
            throw 'The name cannot be empty';
        }
        this._name = newName;
    }
}

let person = new Person('John Winchester');

console.log(person.name)

person.name = "Harry Potter";

console.log(person.name)
 
Note : if the Person class has the name getter but not the name setter. It attempts to call the setter. However, the change doesn’t take effect since the Person class doesn’t have the name setter.(you’d actually see this in error message)

How do you declare private and static variables in classes
Private variables in classes. Take a look at below example.
class Person {
    #name
    constructor(name) {
        this.#name = "masai";
    }
    #privateMethod(){
      return 'Hello';
    }
    getPrivateMessage(){
      return this.#name;
    }
}

const person = new Person("Barry Allen");

console.log(person.property) //undefined

console.log(person.privateMethod) // undefined

console.log(person.getPrivateMessage())
 
Static variables in classes. Take a look at below example.
class Example {
   static staticVariable = 'Some Static Variable';

  //static variable defined
   static staticMethod() {
     return 'static method has been called.';
      }
  }
  // static variable called
  console.log(Example.staticVariable);
  // static method called
  console.log(Example.staticMethod());
 




Explain event delegation​
Event delegation is a technique involving adding event listeners to a parent element instead of adding them to the descendant elements. The listener will fire whenever the event is triggered on the descendant elements due to event bubbling up the DOM. The benefits of this technique are:
Memory footprint goes down because only one single handler is needed on the parent element, rather than having to attach event handlers on each descendant.
There is no need to unbind the handler from elements that are removed and to bind the event for new elements.
References​
https://davidwalsh.name/event-delegate
https://stackoverflow.com/questions/1687296/what-is-dom-event-delegation
Explain how this works in JavaScript​
There's no simple explanation for this; it is one of the most confusing concepts in JavaScript. A hand-wavey explanation is that the value of this depends on how the function is called. I have read many explanations on this online, and I found Arnav Aggrawal's explanation to be the clearest. The following rules are applied:
If the new keyword is used when calling the function, this inside the function is a brand new object.
If apply, call, or bind are used to call/create a function, this inside the function is the object that is passed in as the argument.
If a function is called as a method, such as obj.method() — this is the object that the function is a property of.
If a function is invoked as a free function invocation, meaning it was invoked without any of the conditions present above, this is the global object. In a browser, it is the window object. If in strict mode ('use strict'), this will be undefined instead of the global object.
If multiple of the above rules apply, the rule that is higher wins and will set the this value.
If the function is an ES2015 arrow function, it ignores all the rules above and receives the this value of its surrounding scope at the time it is created.
For an in-depth explanation, do check out his article on Medium.
Can you give an example of one of the ways that working with this has changed in ES6?​
ES6 allows you to use arrow functions which uses the enclosing lexical scope. This is usually convenient, but does prevent the caller from controlling context via .call or .apply—the consequences being that a library such as jQuery will not properly bind this in your event handler functions. Thus, it's important to keep this in mind when refactoring large legacy applications.
References​
https://codeburst.io/the-simple-rules-to-this-in-javascript-35d97f31bde3
https://stackoverflow.com/a/3127440/1751946

Explain how prototypal inheritance works​
This is an extremely common JavaScript interview question. All JavaScript objects have a __proto__ property with the exception of objects created with __Object.create(null)__, that is a reference to another object, which is called the object's "prototype". When a property is accessed on an object and if the property is not found on that object, the JavaScript engine looks at the object's __proto__, and the __proto__'s __proto__ and so on, until it finds the property defined on one of the __proto__s or until it reaches the end of the prototype chain. This behavior simulates classical inheritance, but it is really more of delegation than inheritance.
Example of Prototypal Inheritance​
function Parent() {
 this.name = 'Parent';
}
 
Parent.prototype.greet = function () {
 console.log('Hello from ' + this.name);
};
 
const child = Object.create(Parent.prototype);
 
child.cry = function () {
 console.log('waaaaaahhhh!');
};
 
child.cry();
// waaaaaahhhh!
 
child.greet();
// hello from Parent
 
child.constructor;
// ƒ Parent() {
//   this.name = 'Parent';
// }
 
child.constructor.name;
// 'Parent'
Things to note are:
.greet is not defined on the child, so the engine goes up the prototype chain and finds .greet off the inherited from Parent.
We need to call Object.create in one of following ways for the prototype methods to be inherited:
Object.create(Parent.prototype);
Object.create(new Parent(null));
Object.create(objLiteral);
Currently, child.constructor is pointing to the Parent:
If we'd like to correct this, one option would be to do:
function Parent() {
 this.name = 'Parent';
}
 
Parent.prototype.greet = function () {
 console.log('Hello from ' + this.name);
};
 
function Child() {
 Parent.call(this);
 this.name = 'Child';
}
 
Child.prototype = Object.create(Parent.prototype);
Child.prototype.constructor = Child;
 
const child = new Child();
 
child.greet();
// hello from Child
 
child.constructor.name;
// 'Child'
References​
http://dmitrysoshnikov.com/ecmascript/javascript-the-core/
https://www.quora.com/What-is-prototypal-inheritance/answer/Kyle-Simpson
https://davidwalsh.name/javascript-objects
https://crockford.com/javascript/prototypal.html
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain


Explain why the following doesn't work as an IIFE: function foo(){ }();. What needs to be changed to properly make it an IIFE?​
IIFE stands for Immediately Invoked Function Expressions. The JavaScript parser reads function foo(){ }(); as function foo(){ } and ();, where the former is a function declaration and the latter (a pair of parentheses) is an attempt at calling a function but there is no name specified, hence it throws Uncaught SyntaxError: Unexpected token ).
Here are two ways to fix it that involves adding more parentheses: (function foo(){ })() and (function foo(){ }()). Statements that begin with function are considered to be function declarations; by wrapping this function within (), it becomes a function expression which can then be executed with the subsequent (). These functions are not exposed in the global scope and you can even omit its name if you do not need to reference itself within the body.
You might also use void operator: void function foo(){ }();. Unfortunately, there is one issue with such approach. The evaluation of given expression is always undefined, so if your IIFE function returns anything, you can't use it. An example:
const foo = void (function bar() {
 return 'foo';
})();
 
console.log(foo); // undefined
References​
http://lucybain.com/blog/2014/immediately-invoked-function-expression/
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/void

What's the difference between a variable that is: null, undefined or undeclared? How would you go about checking for any of these states?​
Undeclared variables are created when you assign a value to an identifier that is not previously created using var, let or const. Undeclared variables will be defined globally, outside of the current scope. In strict mode, a ReferenceError will be thrown when you try to assign to an undeclared variable. Undeclared variables are bad just like how global variables are bad. Avoid them at all cost! To check for them, wrap its usage in a try/catch block.
function foo() {
 x = 1; // Throws a ReferenceError in strict mode
}
 
foo();
console.log(x); // 1
A variable that is undefined is a variable that has been declared, but not assigned a value. It is of type undefined. If a function does not return any value as the result of executing it is assigned to a variable, the variable also has the value of undefined. To check for it, compare using the strict equality (===) operator or typeof which will give the 'undefined' string. Note that you should not be using the abstract equality operator to check, as it will also return true if the value is null.
var foo;
console.log(foo); // undefined
console.log(foo === undefined); // true
console.log(typeof foo === 'undefined'); // true
 
console.log(foo == null); // true. Wrong, don't use this to check!
 
function bar() {}
var baz = bar();
console.log(baz); // undefined
A variable that is null will have been explicitly assigned to the null value. It represents no value and is different from undefined in the sense that it has been explicitly assigned. To check for null, simply compare using the strict equality operator. Note that like the above, you should not be using the abstract equality operator (==) to check, as it will also return true if the value is undefined.
var foo = null;
console.log(foo === null); // true
console.log(typeof foo === 'object'); // true
 
console.log(foo == undefined); // true. Wrong, don't use this to check!
As a personal habit, I never leave my variables undeclared or unassigned. I will explicitly assign null to them after declaring if I don't intend to use it yet. If you use a linter in your workflow, it will usually also be able to check that you are not referencing undeclared variables.
References​
https://stackoverflow.com/questions/15985875/effect-of-declared-and-undeclared-variables
https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/undefined

What is a closure, and how/why would you use one?​
A closure is the combination of a function and the lexical environment within which that function was declared. The word "lexical" refers to the fact that lexical scoping uses the location where a variable is declared within the source code to determine where that variable is available. Closures are functions that have access to the outer (enclosing) function's variables—scope chain even after the outer function has returned.
Why would you use one?
Data privacy / emulating private methods with closures. Commonly used in the module pattern.
Partial applications or currying.
References​
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures
https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-closure-b2f0d2152b36

Can you describe the main difference between a .forEach loop and a .map() loop and why you would pick one versus the other?​
To understand the differences between the two, let's look at what each function does.
forEach
Iterates through the elements in an array.
Executes a callback for each element.
Does not return a value.
const a = [1, 2, 3];
const doubled = a.forEach((num, index) => {
 // Do something with num and/or index.
});
 
// doubled = undefined
map
Iterates through the elements in an array.
"Maps" each element to a new element by calling the function on each element, creating a new array as a result.
const a = [1, 2, 3];
const doubled = a.map((num) => {
 return num * 2;
});
 
// doubled = [2, 4, 6]
The main difference between .forEach and .map() is that .map() returns a new array. If you need the result, but do not wish to mutate the original array, .map() is the clear choice. If you simply need to iterate over an array, forEach is a fine choice.
References​
https://codeburst.io/javascript-map-vs-foreach-f38111822c0f

What's a typical use case for anonymous functions?​
They can be used in IIFEs to encapsulate some code within a local scope so that variables declared in it do not leak to the global scope.
(function () {
 // Some code here.
})();
As a callback that is used once and does not need to be used anywhere else. The code will seem more self-contained and readable when handlers are defined right inside the code calling them, rather than having to search elsewhere to find the function body.
setTimeout(function () {
 console.log('Hello world!');
}, 1000);
Arguments to functional programming constructs or Lodash (similar to callbacks).
const arr = [1, 2, 3];
const double = arr.map(function (el) {
 return el * 2;
});
console.log(double); // [2, 4, 6]
References​
https://www.quora.com/What-is-a-typical-usecase-for-anonymous-functions
https://stackoverflow.com/questions/10273185/what-are-the-benefits-to-using-anonymous-functions-instead-of-named-functions-fo

How do you organize your code? (module pattern, classical inheritance?)​
In the past, I've used Backbone for my models which encourages a more OOP approach, creating Backbone models and attaching methods to them.
The module pattern is still great, but these days, I use React/Redux which utilize a single-directional data flow based on Flux architecture. I would represent my app's models using plain objects and write utility pure functions to manipulate these objects. State is manipulated using actions and reducers like in any other Redux application.
I avoid using classical inheritance where possible. When and if I do, I stick to these rules.

What's the difference between host objects and native objects?​
Native objects are objects that are part of the JavaScript language defined by the ECMAScript specification, such as String, Math, RegExp, Object, Function, etc.
Host objects are provided by the runtime environment (browser or Node), such as window, XMLHTTPRequest, etc.
References​
https://stackoverflow.com/questions/7614317/what-is-the-difference-between-native-objects-and-host-objects

Difference between: function Person(){}, var person = Person(), and var person = new Person()?​
This question is pretty vague. My best guess at its intention is that it is asking about constructors in JavaScript. Technically speaking, function Person(){} is just a normal function declaration. The convention is to use PascalCase for functions that are intended to be used as constructors.
var person = Person() invokes the Person as a function, and not as a constructor. Invoking as such is a common mistake if the function is intended to be used as a constructor. Typically, the constructor does not return anything, hence invoking the constructor like a normal function will return undefined and that gets assigned to the variable intended as the instance.
var person = new Person() creates an instance of the Person object using the new operator, which inherits from Person.prototype. An alternative would be to use Object.create, such as: Object.create(Person.prototype).
function Person(name) {
 this.name = name;
}
 
var person = Person('John');
console.log(person); // undefined
console.log(person.name); // Uncaught TypeError: Cannot read property 'name' of undefined
 
var person = new Person('John');
console.log(person); // Person { name: "John" }
console.log(person.name); // "john"
References​
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new

What's the difference between .call and .apply?​
Both .call and .apply are used to invoke functions and the first parameter will be used as the value of this within the function. However, .call takes in comma-separated arguments as the next arguments while .apply takes in an array of arguments as the next argument. An easy way to remember this is C for call and comma-separated and A for apply and an array of arguments.
function add(a, b) {
 return a + b;
}
 
console.log(add.call(null, 1, 2)); // 3
console.log(add.apply(null, [1, 2])); // 3

Explain Function.prototype.bind.​
Taken word-for-word from MDN:
The bind() method creates a new function that, when called, has its this keyword set to the provided value, with a given sequence of arguments preceding any provided when the new function is called.
In my experience, it is most useful for binding the value of this in methods of classes that you want to pass into other functions. This is frequently done in React components.
References​
https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind

When would you use document.write()?​
document.write() writes a string of text to a document stream opened by document.open(). When document.write() is executed after the page has loaded, it will call document.open which clears the whole document (<head> and <body> removed!) and replaces the contents with the given parameter value. Hence it is usually considered dangerous and prone to misuse.
There are some answers online that explain document.write() is being used in analytics code or when you want to include styles that should only work if JavaScript is enabled. It is even being used in HTML5 boilerplate to load scripts in parallel and preserve execution order! However, I suspect those reasons might be outdated and in the modern day, they can be achieved without using document.write(). Please do correct me if I'm wrong about this.
References​
https://www.quirksmode.org/blog/archives/2005/06/three_javascrip_1.html
https://github.com/h5bp/html5-boilerplate/wiki/Script-Loading-Techniques#documentwrite-script-tag

What's the difference between feature detection, feature inference, and using the UA string?​
Feature Detection
Feature detection involves working out whether a browser supports a certain block of code, and running different code depending on whether it does (or doesn't), so that the browser can always provide a working experience rather crashing/erroring in some browsers. For example:
if ('geolocation' in navigator) {
 // Can use navigator.geolocation
} else {
 // Handle lack of feature
}
Modernizr is a great library to handle feature detection.
Feature Inference
Feature inference checks for a feature just like feature detection, but uses another function because it assumes it will also exist, e.g.:
if (document.getElementsByTagName) {
 element = document.getElementById(id);
}
This is not really recommended. Feature detection is more foolproof.
UA String
This is a browser-reported string that allows the network protocol peers to identify the application type, operating system, software vendor or software version of the requesting software user agent. It can be accessed via navigator.userAgent. However, the string is tricky to parse and can be spoofed. For example, Chrome reports both as Chrome and Safari. So to detect Safari you have to check for the Safari string and the absence of the Chrome string. Avoid this method.
References​
https://developer.mozilla.org/en-US/docs/Learn/Tools_and_testing/Cross_browser_testing/Feature_detection
https://stackoverflow.com/questions/20104930/whats-the-difference-between-feature-detection-feature-inference-and-using-th
https://developer.mozilla.org/en-US/docs/Web/HTTP/Browser_detection_using_the_user_agent

Explain Ajax in as much detail as possible.​
Ajax (asynchronous JavaScript and XML) is a set of web development techniques using many web technologies on the client side to create asynchronous web applications. With Ajax, web applications can send data to and retrieve from a server asynchronously (in the background) without interfering with the display and behavior of the existing page. By decoupling the data interchange layer from the presentation layer, Ajax allows for web pages, and by extension web applications, to change content dynamically without the need to reload the entire page. In practice, modern implementations commonly use JSON instead of XML, due to the advantages of JSON being native to JavaScript.
The XMLHttpRequest API is frequently used for the asynchronous communication or these days, the fetch API.
References​
https://en.wikipedia.org/wiki/Ajax_(programming)
https://developer.mozilla.org/en-US/docs/AJAX

What are the advantages and disadvantages of using Ajax?​
Advantages
Better interactivity. New content from the server can be changed dynamically without the need to reload the entire page.
Reduce connections to the server since scripts and stylesheets only have to be requested once.
State can be maintained on a page. JavaScript variables and DOM state will persist because the main container page was not reloaded.
Basically most of the advantages of an SPA.
Disadvantages
Dynamic webpages are harder to bookmark.
Does not work if JavaScript has been disabled in the browser.
Some webcrawlers do not execute JavaScript and would not see content that has been loaded by JavaScript.
Webpages using Ajax to fetch data will likely have to combine the fetched remote data with client-side templates to update the DOM. For this to happen, JavaScript will have to be parsed and executed on the browser, and low-end mobile devices might struggle with this.
Basically most of the disadvantages of an SPA.

Explain how JSONP works (and how it's not really Ajax).​
JSONP (JSON with Padding) is a method commonly used to bypass the cross-domain policies in web browsers because Ajax requests from the current page to a cross-origin domain is not allowed.
JSONP works by making a request to a cross-origin domain via a <script> tag and usually with a callback query parameter, for example: https://example.com?callback=printData. The server will then wrap the data within a function called printData and return it to the client.
<!-- https://mydomain.com -->
<script>
 function printData(data) {
   console.log(`My name is ${data.name}!`);
 }
</script>
 
<script src="https://example.com?callback=printData"></script>
// File loaded from https://example.com?callback=printData
printData({name: 'Yang Shun'});
The client has to have the printData function in its global scope and the function will be executed by the client when the response from the cross-origin domain is received.
JSONP can be unsafe and has some security implications. As JSONP is really JavaScript, it can do everything else JavaScript can do, so you need to trust the provider of the JSONP data.
These days, CORS is the recommended approach and JSONP is seen as a hack.
References​
https://stackoverflow.com/a/2067584/1751946

Have you ever used JavaScript templating? If so, what libraries have you used?​
Yes. Handlebars, Underscore, Lodash, AngularJS, and JSX. I disliked templating in AngularJS because it made heavy use of strings in the directives and typos would go uncaught. JSX is my new favorite as it is closer to JavaScript and there is barely any syntax to learn. Nowadays, you can even use ES2015 template string literals as a quick way for creating templates without relying on third-party code.
const template = `<div>My name is: ${name}</div>`;
However, do be aware of a potential XSS in the above approach as the contents are not escaped for you, unlike in templating libraries.

Explain "hoisting".​
Hoisting is a term used to explain the behavior of variable declarations in your code. Variables declared or initialized with the var keyword will have their declaration "moved" up to the top of their module/function-level scope, which we refer to as hoisting. However, only the declaration is hoisted, the assignment (if there is one), will stay where it is.
Note that the declaration is not actually moved - the JavaScript engine parses the declarations during compilation and becomes aware of declarations and their scopes. It is just easier to understand this behavior by visualizing the declarations as being hoisted to the top of their scope. Let's explain with a few examples.
console.log(foo); // undefined
var foo = 1;
console.log(foo); // 1
Function declarations have the body hoisted while the function expressions (written in the form of variable declarations) only has the variable declaration hoisted.
// Function Declaration
console.log(foo); // [Function: foo]
foo(); // 'FOOOOO'
function foo() {
 console.log('FOOOOO');
}
console.log(foo); // [Function: foo]
 
// Function Expression
console.log(bar); // undefined
bar(); // Uncaught TypeError: bar is not a function
var bar = function () {
 console.log('BARRRR');
};
console.log(bar); // [Function: bar]
Variables declared via let and const are hoisted as well. However, unlike var and function, they are not initialized and accessing them before the declaration will result in a ReferenceError exception. The variable is in a "temporal dead zone" from the start of the block until the declaration is processed.
x; // undefined
y; // Reference error: y is not defined
 
var x = 'local';
let y = 'local';
References​
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Grammar_and_Types#Variable_hoisting
https://stackoverflow.com/questions/31219420/are-variables-declared-with-let-or-const-not-hoisted-in-es6/31222689#31222689

Describe event bubbling.​
When an event triggers on a DOM element, it will attempt to handle the event if there is a listener attached, then the event is bubbled up to its parent and the same thing happens. This bubbling occurs up the element's ancestors all the way to the document. Event bubbling is the mechanism behind event delegation.

What's the difference between an "attribute" and a "property"?​
Attributes are defined on the HTML markup but properties are defined on the DOM. To illustrate the difference, imagine we have this text field in our HTML: <input type="text" value="Hello">.
const input = document.querySelector('input');
console.log(input.getAttribute('value')); // Hello
console.log(input.value); // Hello
But after you change the value of the text field by adding "World!" to it, this becomes:
console.log(input.getAttribute('value')); // Hello
console.log(input.value); // Hello World!
References​
https://stackoverflow.com/questions/6003819/properties-and-attributes-in-html

Why is extending built-in JavaScript objects not a good idea?​
Extending a built-in/native JavaScript object means adding properties/functions to its prototype. While this may seem like a good idea at first, it is dangerous in practice. Imagine your code uses a few libraries that both extend the Array.prototype by adding the same contains method, the implementations will overwrite each other and your code will break if the behavior of these two methods is not the same.
The only time you may want to extend a native object is when you want to create a polyfill, essentially providing your own implementation for a method that is part of the JavaScript specification but might not exist in the user's browser due to it being an older browser.
References​
http://lucybain.com/blog/2014/js-extending-built-in-objects/

Difference between document load event and document DOMContentLoaded event?​
The DOMContentLoaded event is fired when the initial HTML document has been completely loaded and parsed, without waiting for stylesheets, images, and subframes to finish loading.
window's load event is only fired after the DOM and all dependent resources and assets have loaded.
References​
https://developer.mozilla.org/en-US/docs/Web/Events/DOMContentLoaded
https://developer.mozilla.org/en-US/docs/Web/Events/load

What is the difference between == and ===?​
== is the abstract equality operator while === is the strict equality operator. The == operator will compare for equality after doing any necessary type conversions. The === operator will not do type conversion, so if two values are not the same type === will simply return false. When using ==, funky things can happen, such as:
1 == '1'; // true
1 == [1]; // true
1 == true; // true
0 == ''; // true
0 == '0'; // true
0 == false; // true
My advice is never to use the == operator, except for convenience when comparing against null or undefined, where a == null will return true if a is null or undefined.
var a = null;
console.log(a == null); // true
console.log(a == undefined); // true
References​
https://stackoverflow.com/questions/359494/which-equals-operator-vs-should-be-used-in-javascript-comparisons

Explain the same-origin policy with regards to JavaScript.​
The same-origin policy prevents JavaScript from making requests across domain boundaries. An origin is defined as a combination of URI scheme, hostname, and port number. This policy prevents a malicious script on one page from obtaining access to sensitive data on another web page through that page's Document Object Model.
References​
https://en.wikipedia.org/wiki/Same-origin_policy

Make this work:​
duplicate([1, 2, 3, 4, 5]); // [1,2,3,4,5,1,2,3,4,5]
function duplicate(arr) {
 return arr.concat(arr);
}
 
duplicate([1, 2, 3, 4, 5]); // [1,2,3,4,5,1,2,3,4,5]
Or with ES6:
const duplicate = (arr) => [...arr, ...arr];
 
duplicate([1, 2, 3, 4, 5]); // [1,2,3,4,5,1,2,3,4,5]

Why is it called a Ternary expression, what does the word "Ternary" indicate?​
"Ternary" indicates three, and a ternary expression accepts three operands, the test condition, the "then" expression and the "else" expression. Ternary expressions are not specific to JavaScript and I'm not sure why it is even in this list.
References​
https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Operators/Conditional_Operator

What is "use strict";? What are the advantages and disadvantages to using it?​
'use strict' is a statement used to enable strict mode to entire scripts or individual functions. Strict mode is a way to opt into a restricted variant of JavaScript.
Advantages:
Makes it impossible to accidentally create global variables.
Makes assignments which would otherwise silently fail to throw an exception.
Makes attempts to delete undeletable properties throw (where before the attempt would simply have no effect).
Requires that function parameter names be unique.
this is undefined in the global context.
It catches some common coding bloopers, throwing exceptions.
It disables features that are confusing or poorly thought out.
Disadvantages:
Many missing features that some developers might be used to.
No more access to function.caller and function.arguments.
Concatenation of scripts written in different strict modes might cause issues.
Overall, I think the benefits outweigh the disadvantages, and I never had to rely on the features that strict mode blocks. I would recommend using strict mode.
References​
http://2ality.com/2011/10/strict-mode-hatred.html
http://lucybain.com/blog/2014/js-use-strict/

Create a for loop that iterates up to 100 while outputting "fizz" at multiples of 3, "buzz" at multiples of 5 and "fizzbuzz" at multiples of 3 and 5.​
Check out this version of FizzBuzz by Paul Irish.
for (let i = 1; i <= 100; i++) {
 let f = i % 3 == 0,
   b = i % 5 == 0;
 console.log(f ? (b ? 'FizzBuzz' : 'Fizz') : b ? 'Buzz' : i);
}
I would not advise you to write the above during interviews though. Just stick with the long but clear approach. For more wacky versions of FizzBuzz, check out the reference link below.
References​
https://gist.github.com/jaysonrowe/1592432

Why is it, in general, a good idea to leave the global scope of a website as-is and never touch it?​
Every script has access to the global scope, and if everyone uses the global namespace to define their variables, collisions will likely occur. Use the module pattern (IIFEs) to encapsulate your variables within a local namespace.

Why would you use something like the load event? Does this event have disadvantages? Do you know any alternatives, and why would you use those?​
The load event fires at the end of the document loading process. At this point, all of the objects in the document are in the DOM, and all the images, scripts, links and sub-frames have finished loading.
The DOM event DOMContentLoaded will fire after the DOM for the page has been constructed, but do not wait for other resources to finish loading. This is preferred in certain cases when you do not need the full page to be loaded before initializing.
TODO.
References​
https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers/onload

Explain what a single page app is and how to make one SEO-friendly.​
The below is taken from the awesome Grab Front End Guide, which coincidentally, is written by me!
Web developers these days refer to the products they build as web apps, rather than websites. While there is no strict difference between the two terms, web apps tend to be highly interactive and dynamic, allowing the user to perform actions and receive a response to their action. Traditionally, the browser receives HTML from the server and renders it. When the user navigates to another URL, a full-page refresh is required and the server sends fresh new HTML to the new page. This is called server-side rendering.
However, in modern SPAs, client-side rendering is used instead. The browser loads the initial page from the server, along with the scripts (frameworks, libraries, app code) and stylesheets required for the whole app. When the user navigates to other pages, a page refresh is not triggered. The URL of the page is updated via the HTML5 History API. New data required for the new page, usually in JSON format, is retrieved by the browser via AJAX requests to the server. The SPA then dynamically updates the page with the data via JavaScript, which it has already downloaded in the initial page load. This model is similar to how native mobile apps work.
The benefits:
The app feels more responsive and users do not see the flash between page navigations due to full-page refreshes.
Fewer HTTP requests are made to the server, as the same assets do not have to be downloaded again for each page load.
Clear separation of the concerns between the client and the server; you can easily build new clients for different platforms (e.g. mobile, chatbots, smart watches) without having to modify the server code. You can also modify the technology stack on the client and server independently, as long as the API contract is not broken.
The downsides:
Heavier initial page load due to the loading of framework, app code, and assets required for multiple pages.
There's an additional step to be done on your server which is to configure it to route all requests to a single entry point and allow client-side routing to take over from there.
SPAs are reliant on JavaScript to render content, but not all search engines execute JavaScript during crawling, and they may see empty content on your page. This inadvertently hurts the Search Engine Optimization (SEO) of your app. However, most of the time, when you are building apps, SEO is not the most important factor, as not all the content needs to be indexable by search engines. To overcome this, you can either server-side render your app or use services such as Prerender to "render your javascript in a browser, save the static HTML, and return that to the crawlers".
References​
https://github.com/grab/front-end-guide#single-page-apps-spas
http://stackoverflow.com/questions/21862054/single-page-app-advantages-and-disadvantages
http://blog.isquaredsoftware.com/presentations/2016-10-revolution-of-web-dev/
https://medium.freecodecamp.com/heres-why-client-side-rendering-won-46a349fadb52

What is the extent of your experience with Promises and/or their polyfills?​
Possess working knowledge of it. A promise is an object that may produce a single value sometime in the future: either a resolved value or a reason that it's not resolved (e.g., a network error occurred). A promise may be in one of 3 possible states: fulfilled, rejected, or pending. Promise users can attach callbacks to handle the fulfilled value or the reason for rejection.
Some common polyfills are $.deferred, Q and Bluebird but not all of them comply with the specification. ES2015 supports Promises out of the box and polyfills are typically not needed these days.
References​
https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-promise-27fc71e77261

What are the pros and cons of using Promises instead of callbacks?​
Pros
Avoid callback hell which can be unreadable.
Makes it easy to write sequential asynchronous code that is readable with .then().
Makes it easy to write parallel asynchronous code with Promise.all().
With promises, these scenarios which are present in callbacks-only coding, will not happen:
Call the callback too early
Call the callback too late (or never)
Call the callback too few or too many times
Fail to pass along any necessary environment/parameters
Swallow any errors/exceptions that may happen
Cons
Slightly more complex code (debatable).
In older browsers where ES2015 is not supported, you need to load a polyfill in order to use it.
References​
https://github.com/getify/You-Dont-Know-JS/blob/master/async%20%26%20performance/ch3.md

What are some of the advantages/disadvantages of writing JavaScript code in a language that compiles to JavaScript?​
Some examples of languages that compile to JavaScript include CoffeeScript, Elm, ClojureScript, PureScript, and TypeScript.
Advantages:
Fixes some of the longstanding problems in JavaScript and discourages JavaScript anti-patterns.
Enables you to write shorter code, by providing some syntactic sugar on top of JavaScript, which I think ES5 lacks, but ES2015 is awesome.
Static types are awesome (in the case of TypeScript) for large projects that need to be maintained over time.
Disadvantages:
Require a build/compile process as browsers only run JavaScript and your code will need to be compiled into JavaScript before being served to browsers.
Debugging can be a pain if your source maps do not map nicely to your pre-compiled source.
Most developers are not familiar with these languages and will need to learn it. There's a ramp up cost involved for your team if you use it for your projects.
Smaller community (depends on the language), which means resources, tutorials, libraries, and tooling would be harder to find.
IDE/editor support might be lacking.
These languages will always be behind the latest JavaScript standard.
Developers should be cognizant of what their code is being compiled to — because that is what would actually be running, and that is what matters in the end.
Practically, ES2015 has vastly improved JavaScript and made it much nicer to write. I don't really see the need for CoffeeScript these days.
References​
https://softwareengineering.stackexchange.com/questions/72569/what-are-the-pros-and-cons-of-coffeescript

What tools and techniques do you use for debugging JavaScript code?​
React and Redux
React Devtools
Redux Devtools
Vue
Vue Devtools
JavaScript
Chrome Devtools
debugger statement
Good old console.log debugging
References​
https://hackernoon.com/twelve-fancy-chrome-devtools-tips-dc1e39d10d9d
https://raygun.com/blog/javascript-debugging/

What language constructions do you use for iterating over object properties and array items?​
For objects:
for-in loops - for (var property in obj) { console.log(property); }. However, this will also iterate through its inherited properties, and you will add an obj.hasOwnProperty(property) check before using it.
Object.keys() - Object.keys(obj).forEach(function (property) { ... }). Object.keys() is a static method that will lists all enumerable properties of the object that you pass it.
Object.getOwnPropertyNames() - Object.getOwnPropertyNames(obj).forEach(function (property) { ... }). Object.getOwnPropertyNames() is a static method that will lists all enumerable and non-enumerable properties of the object that you pass it.
For arrays:
for loops - for (var i = 0; i < arr.length; i++). The common pitfall here is that var is in the function scope and not the block scope and most of the time you would want block scoped iterator variable. ES2015 introduces let which has block scope and it is recommended to use that instead. So this becomes: for (let i = 0; i < arr.length; i++).
forEach - arr.forEach(function (el, index) { ... }). This construct can be more convenient at times because you do not have to use the index if all you need is the array elements. There are also the every and some methods which will allow you to terminate the iteration early.
for-of loops - for (let elem of arr) { ... }. ES6 introduces a new loop, the for-of loop, that allows you to loop over objects that conform to the iterable protocol such as String, Array, Map, Set, etc. It combines the advantages of the for loop and the forEach() method. The advantage of the for loop is that you can break from it, and the advantage of forEach() is that it is more concise than the for loop because you don't need a counter variable. With the for-of loop, you get both the ability to break from a loop and a more concise syntax.
Most of the time, I would prefer the .forEach method, but it really depends on what you are trying to do. Before ES6, we used for loops when we needed to prematurely terminate the loop using break. But now with ES6, we can do that with for-of loops. I would use for loops when I need even more flexibility, such as incrementing the iterator more than once per loop.
Also, when using the for-of loop, if you need to access both the index and value of each array element, you can do so with the ES6 Array entries() method and destructuring:
const arr = ['a', 'b', 'c'];
 
for (let [index, elem] of arr.entries()) {
 console.log(index, ': ', elem);
}
References​
http://2ality.com/2015/08/getting-started-es6.html#from-for-to-foreach-to-for-of
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/entries

Explain the difference between mutable and immutable objects.​
Immutability is a core principle in functional programming, and has lots to offer to object-oriented programs as well. A mutable object is an object whose state can be modified after it is created. An immutable object is an object whose state cannot be modified after it is created.
What is an example of an immutable object in JavaScript?​
In JavaScript, some built-in types (numbers, strings) are immutable, but custom objects are generally mutable.
Some built-in immutable JavaScript objects are Math, Date.
Here are a few ways to add/simulate immutability on plain JavaScript objects.
Object Constant Properties
By combining writable: false and configurable: false, you can essentially create a constant (cannot be changed, redefined or deleted) as an object property, like:
let myObject = {};
Object.defineProperty(myObject, 'number', {
 value: 42,
 writable: false,
 configurable: false,
});
console.log(myObject.number); // 42
myObject.number = 43;
console.log(myObject.number); // 42
Prevent Extensions
If you want to prevent an object from having new properties added to it, but otherwise leave the rest of the object's properties alone, call Object.preventExtensions(...):
var myObject = {
 a: 2,
};
 
Object.preventExtensions(myObject);
 
myObject.b = 3;
myObject.b; // undefined
In non-strict mode, the creation of b fails silently. In strict mode, it throws a TypeError.
Seal
Object.seal() creates a "sealed" object, which means it takes an existing object and essentially calls Object.preventExtensions() on it, but also marks all its existing properties as configurable: false.
So, not only can you not add any more properties, but you also cannot reconfigure or delete any existing properties (though you can still modify their values).
Freeze
Object.freeze() creates a frozen object, which means it takes an existing object and essentially calls Object.seal() on it, but it also marks all "data accessor" properties as writable:false, so that their values cannot be changed.
This approach is the highest level of immutability that you can attain for an object itself, as it prevents any changes to the object or to any of its direct properties (though, as mentioned above, the contents of any referenced other objects are unaffected).
var immutable = Object.freeze({});
Freezing an object does not allow new properties to be added to an object and prevents from removing or altering the existing properties. Object.freeze() preserves the enumerability, configurability, writability and the prototype of the object. It returns the passed object and does not create a frozen copy.
What are the pros and cons of immutability?​
Pros
Easier change detection - Object equality can be determined in a performant and easy manner through referential equality. This is useful for comparing object differences in React and Redux.
Programs with immutable objects are less complicated to think about, since you don't need to worry about how an object may evolve over time.
Defensive copies are no longer necessary when immutable objects are returning from or passed to functions, since there is no possibility an immutable object will be modified by it.
Easy sharing via references - One copy of an object is just as good as another, so you can cache objects or reuse the same object multiple times.
Thread-safe - Immutable objects can be safely used between threads in a multi-threaded environment since there is no risk of them being modified in other concurrently running threads.
Using libraries like ImmmutableJS, objects are modified using structural sharing and less memory is needed for having multiple objects with similar structures.
Cons
Naive implementations of immutable data structures and its operations can result in extremely poor performance because new objects are created each time. It is recommended to use libraries for efficient immutable data structures and operations that leverage on structural sharing.
Allocation (and deallocation) of many small objects rather than modifying existing ones can cause a performance impact. The complexity of either the allocator or the garbage collector usually depends on the number of objects on the heap.
Cyclic data structures such as graphs are difficult to build. If you have two objects which can't be modified after initialization, how can you get them to point to each other?
References​
https://stackoverflow.com/questions/1863515/pros-cons-of-immutability-vs-mutability

How can you achieve immutability in your own code?​
One way to achieve immutability is to use libraries like immutable.js, mori or immer.
The alternative is to use const declarations combined with the techniques mentioned above for creation. For "mutating" objects, use the spread operator, Object.assign, Array.concat(), etc., to create new objects instead of mutate the original object.
Examples:
// Array Example
const arr = [1, 2, 3];
const newArr = [...arr, 4]; // [1, 2, 3, 4]
 
// Object Example
const human = Object.freeze({race: 'human'});
const john = {...human, name: 'John'}; // {race: "human", name: "John"}
const alienJohn = {...john, race: 'alien'}; // {race: "alien", name: "John"}
References​
https://stackoverflow.com/questions/1863515/pros-cons-of-immutability-vs-mutability
https://www.sitepoint.com/immutability-javascript/
https://wecodetheweb.com/2016/02/12/immutable-javascript-using-es6-and-beyond/

Explain the difference between synchronous and asynchronous functions.​
Synchronous functions are blocking while asynchronous functions are not. In synchronous functions, statements complete before the next statement is run. In this case, the program is evaluated exactly in order of the statements and execution of the program is paused if one of the statements take a very long time.
Asynchronous functions usually accept a callback as a parameter and execution continue on the next line immediately after the asynchronous function is invoked. The callback is only invoked when the asynchronous operation is complete and the call stack is empty. Heavy duty operations such as loading data from a web server or querying a database should be done asynchronously so that the main thread can continue executing other operations instead of blocking until that long operation to complete (in the case of browsers, the UI will freeze).

What is event loop? What is the difference between call stack and task queue?​
The event loop is a single-threaded loop that monitors the call stack and checks if there is any work to be done in the task queue. If the call stack is empty and there are callback functions in the task queue, a function is dequeued and pushed onto the call stack to be executed.
If you haven't already checked out Philip Robert's talk on the Event Loop, you should. It is one of the most viewed videos on JavaScript.
References​
https://2014.jsconf.eu/speakers/philip-roberts-what-the-heck-is-the-event-loop-anyway.html

Explain the differences on the usage of foo between function foo() {} and var foo = function() {}​
The former is a function declaration while the latter is a function expression. The key difference is that function declarations have its body hoisted but the bodies of function expressions are not (they have the same hoisting behavior as variables). For more explanation on hoisting, refer to the question above on hoisting. If you try to invoke a function expression before it is defined, you will get an Uncaught TypeError: XXX is not a function error.
Function Declaration
foo(); // 'FOOOOO'
function foo() {
 console.log('FOOOOO');
}
Function Expression
foo(); // Uncaught TypeError: foo is not a function
var foo = function () {
 console.log('FOOOOO');
};
References​
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function

What are the differences between variables created using let, var or const?​
Variables declared using the var keyword are scoped to the function in which they are created, or if created outside of any function, to the global object. let and const are block scoped, meaning they are only accessible within the nearest set of curly braces (function, if-else block, or for-loop).
function foo() {
 // All variables are accessible within functions.
 var bar = 'bar';
 let baz = 'baz';
 const qux = 'qux';
 
 console.log(bar); // bar
 console.log(baz); // baz
 console.log(qux); // qux
}
 
console.log(bar); // ReferenceError: bar is not defined
console.log(baz); // ReferenceError: baz is not defined
console.log(qux); // ReferenceError: qux is not defined
if (true) {
 var bar = 'bar';
 let baz = 'baz';
 const qux = 'qux';
}
 
// var declared variables are accessible anywhere in the function scope.
console.log(bar); // bar
// let and const defined variables are not accessible outside of the block they were defined in.
console.log(baz); // ReferenceError: baz is not defined
console.log(qux); // ReferenceError: qux is not defined
var allows variables to be hoisted, meaning they can be referenced in code before they are declared. let and const will not allow this, instead throwing an error.
console.log(foo); // undefined
 
var foo = 'foo';
 
console.log(baz); // ReferenceError: can't access lexical declaration 'baz' before initialization
 
let baz = 'baz';
 
console.log(bar); // ReferenceError: can't access lexical declaration 'bar' before initialization
 
const bar = 'bar';
Redeclaring a variable with var will not throw an error, but let and const will.
var foo = 'foo';
var foo = 'bar';
console.log(foo); // "bar"
 
let baz = 'baz';
let baz = 'qux'; // Uncaught SyntaxError: Identifier 'baz' has already been declared
let and const differ in that let allows reassigning the variable's value while const does not.
// This is fine.
let foo = 'foo';
foo = 'bar';
 
// This causes an exception.
const baz = 'baz';
baz = 'qux';
References​
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/var
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const

What are the differences between ES6 class and ES5 function constructors?​
Let's first look at example of each:
// ES5 Function Constructor
function Person(name) {
 this.name = name;
}
 
// ES6 Class
class Person {
 constructor(name) {
   this.name = name;
 }
}
For simple constructors, they look pretty similar.
The main difference in the constructor comes when using inheritance. If we want to create a Student class that subclasses Person and add a studentId field, this is what we have to do in addition to the above.
// ES5 Function Constructor
function Student(name, studentId) {
 // Call constructor of superclass to initialize superclass-derived members.
 Person.call(this, name);
 
 // Initialize subclass's own members.
 this.studentId = studentId;
}
 
Student.prototype = Object.create(Person.prototype);
Student.prototype.constructor = Student;
 
// ES6 Class
class Student extends Person {
 constructor(name, studentId) {
   super(name);
   this.studentId = studentId;
 }
}
It's much more verbose to use inheritance in ES5 and the ES6 version is easier to understand and remember.
References​
https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Inheritance
https://eli.thegreenplace.net/2013/10/22/classical-inheritance-in-javascript-es5

Can you offer a use case for the new arrow => function syntax? How does this new syntax differ from other functions?​
One obvious benefit of arrow functions is to simplify the syntax needed to create functions, without a need for the function keyword. The this within arrow functions is also bound to the enclosing scope which is different compared to regular functions where the this is determined by the object calling it. Lexically-scoped this is useful when invoking callbacks especially in React components.

What advantage is there for using the arrow syntax for a method in a constructor?​
The main advantage of using an arrow function as a method inside a constructor is that the value of this gets set at the time of the function creation and can't change after that. So, when the constructor is used to create a new object, this will always refer to that object. For example, let's say we have a Person constructor that takes a first name as an argument has two methods to console.log that name, one as a regular function and one as an arrow function:
const Person = function (firstName) {
 this.firstName = firstName;
 this.sayName1 = function () {
   console.log(this.firstName);
 };
 this.sayName2 = () => {
   console.log(this.firstName);
 };
};
 
const john = new Person('John');
const dave = new Person('Dave');
 
john.sayName1(); // John
john.sayName2(); // John
 
// The regular function can have its 'this' value changed, but the arrow function cannot
john.sayName1.call(dave); // Dave (because "this" is now the dave object)
john.sayName2.call(dave); // John
 
john.sayName1.apply(dave); // Dave (because 'this' is now the dave object)
john.sayName2.apply(dave); // John
 
john.sayName1.bind(dave)(); // Dave (because 'this' is now the dave object)
john.sayName2.bind(dave)(); // John
 
var sayNameFromWindow1 = john.sayName1;
sayNameFromWindow1(); // undefined (because 'this' is now the window object)
 
var sayNameFromWindow2 = john.sayName2;
sayNameFromWindow2(); // John
The main takeaway here is that this can be changed for a normal function, but the context always stays the same for an arrow function. So even if you are passing around your arrow function to different parts of your application, you wouldn't have to worry about the context changing.
This can be particularly helpful in React class components. If you define a class method for something such as a click handler using a normal function, and then you pass that click handler down into a child component as a prop, you will need to also bind this in the constructor of the parent component. If you instead use an arrow function, there is no need to also bind "this", as the method will automatically get its "this" value from its enclosing lexical context. (See this article for an excellent demonstration and sample code: https://medium.com/@machnicki/handle-events-in-react-with-arrow-functions-ede88184bbb)
References​
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions
https://medium.com/@machnicki/handle-events-in-react-with-arrow-functions-ede88184bbb

What is the definition of a higher-order function?​
A higher-order function is any function that takes one or more functions as arguments, which it uses to operate on some data, and/or returns a function as a result. Higher-order functions are meant to abstract some operation that is performed repeatedly. The classic example of this is map, which takes an array and a function as arguments. map then uses this function to transform each item in the array, returning a new array with the transformed data. Other popular examples in JavaScript are forEach, filter, and reduce. A higher-order function doesn't just need to be manipulating arrays as there are many use cases for returning a function from another function. Function.prototype.bind is one such example in JavaScript.
Map
Let say we have an array of names which we need to transform each string to uppercase.
const names = ['irish', 'daisy', 'anna'];
The imperative way will be as such:
const transformNamesToUppercase = function (names) {
 const results = [];
 for (let i = 0; i < names.length; i++) {
   results.push(names[i].toUpperCase());
 }
 return results;
};
transformNamesToUppercase(names); // ['IRISH', 'DAISY', 'ANNA']
Use .map(transformerFn) makes the code shorter and more declarative.
const transformNamesToUppercase = function (names) {
 return names.map((name) => name.toUpperCase());
};
transformNamesToUppercase(names); // ['IRISH', 'DAISY', 'ANNA']
References​
https://medium.com/javascript-scene/higher-order-functions-composing-software-5365cf2cbe99
https://hackernoon.com/effective-functional-javascript-first-class-and-higher-order-functions-713fde8df50a
https://eloquentjavascript.net/05_higher_order.html

Can you give an example for destructuring an object or an array?​
Destructuring is an expression available in ES6 which enables a succinct and convenient way to extract values of Objects or Arrays and place them into distinct variables.
Array destructuring
// Variable assignment.
const foo = ['one', 'two', 'three'];
 
const [one, two, three] = foo;
console.log(one); // "one"
console.log(two); // "two"
console.log(three); // "three"
// Swapping variables
let a = 1;
let b = 3;
 
[a, b] = [b, a];
console.log(a); // 3
console.log(b); // 1
Object destructuring
// Variable assignment.
const o = {p: 42, q: true};
const {p, q} = o;
 
console.log(p); // 42
console.log(q); // true
References​
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment
https://ponyfoo.com/articles/es6-destructuring-in-depth

ES6 Template Literals offer a lot of flexibility in generating strings, can you give an example?​
Template literals help make it simple to do string interpolation, or to include variables in a string. Before ES2015, it was common to do something like this:
var person = {name: 'Tyler', age: 28};
console.log(
 'Hi, my name is ' + person.name + ' and I am ' + person.age + ' years old!',
);
// 'Hi, my name is Tyler and I am 28 years old!'
With template literals, you can now create that same output like this instead:
const person = {name: 'Tyler', age: 28};
console.log(`Hi, my name is ${person.name} and I am ${person.age} years old!`);
// 'Hi, my name is Tyler and I am 28 years old!'
Note that you use backticks, not quotes, to indicate that you are using a template literal and that you can insert expressions inside the ${} placeholders.
A second helpful use case is in creating multi-line strings. Before ES2015, you could create a multi-line string like this:
console.log('This is line one.\nThis is line two.');
// This is line one.
// This is line two.
Or if you wanted to break it up into multiple lines in your code so you didn't have to scroll to the right in your text editor to read a long string, you could also write it like this:
console.log('This is line one.\n' + 'This is line two.');
// This is line one.
// This is line two.
Template literals, however, preserve whatever spacing you add to them. For example, to create that same multi-line output that we created above, you can simply do:
console.log(`This is line one.
This is line two.`);
// This is line one.
// This is line two.
Another use case of template literals would be to use as a substitute for templating libraries for simple variable interpolations:
const person = {name: 'Tyler', age: 28};
document.body.innerHTML = `
 <div>
   <p>Name: ${person.name}</p>
   <p>Age: ${person.age}</p>
 </div>
`;
Note that your code may be susceptible to XSS by using .innerHTML. Sanitize your data before displaying it if it came from a user!
References​
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals

Can you give an example of a curry function and why this syntax offers an advantage?​
Currying is a pattern where a function with more than one parameter is broken into multiple functions that, when called in series, will accumulate all of the required parameters one at a time. This technique can be useful for making code written in a functional style easier to read and compose. It's important to note that for a function to be curried, it needs to start out as one function, then broken out into a sequence of functions that each accepts one parameter.
function curry(fn) {
 if (fn.length === 0) {
   return fn;
 }
 
 function _curried(depth, args) {
   return function (newArgument) {
     if (depth - 1 === 0) {
       return fn(...args, newArgument);
     }
     return _curried(depth - 1, [...args, newArgument]);
   };
 }
 
 return _curried(fn.length, []);
}
 
function add(a, b) {
 return a + b;
}
 
var curriedAdd = curry(add);
var addFive = curriedAdd(5);
 
var result = [0, 1, 2, 3, 4, 5].map(addFive); // [5, 6, 7, 8, 9, 10]
References​
https://hackernoon.com/currying-in-js-d9ddc64f162e

What are the benefits of using spread syntax and how is it different from rest syntax?​
ES6's spread syntax is very useful when coding in a functional paradigm as we can easily create copies of arrays or objects without resorting to Object.create, slice, or a library function. This language feature is used often in Redux and RxJS projects.
function putDookieInAnyArray(arr) {
 return [...arr, 'dookie'];
}
 
const result = putDookieInAnyArray(['I', 'really', "don't", 'like']); // ["I", "really", "don't", "like", "dookie"]
 
const person = {
 name: 'Todd',
 age: 29,
};
 
const copyOfTodd = {...person};
ES6's rest syntax offers a shorthand for including an arbitrary number of arguments to be passed to a function. It is like an inverse of the spread syntax, taking data and stuffing it into an array rather than unpacking an array of data, and it works in function arguments, as well as in array and object destructuring assignments.
function addFiveToABunchOfNumbers(...numbers) {
 return numbers.map((x) => x + 5);
}
 
const result = addFiveToABunchOfNumbers(4, 5, 6, 7, 8, 9, 10); // [9, 10, 11, 12, 13, 14, 15]
 
const [a, b, ...rest] = [1, 2, 3, 4]; // a: 1, b: 2, rest: [3, 4]
 
const {e, f, ...others} = {
 e: 1,
 f: 2,
 g: 3,
 h: 4,
}; // e: 1, f: 2, others: { g: 3, h: 4 }
References​
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment

How can you share code between files?​
This depends on the JavaScript environment.
On the client (browser environment), as long as the variables/functions are declared in the global scope (window), all scripts can refer to them. Alternatively, adopt the Asynchronous Module Definition (AMD) via RequireJS for a more modular approach.
On the server (Node.js), the common way has been to use CommonJS. Each file is treated as a module and it can export variables and functions by attaching them to the module.exports object.
ES2015 defines a module syntax which aims to replace both AMD and CommonJS. This will eventually be supported in both browser and Node environments.

References​
http://requirejs.org/docs/whyamd.html
https://nodejs.org/docs/latest/api/modules.html
http://2ality.com/2014/09/es6-modules-final.html



REACT 
		 	 	 		
			
				
					
What is React?			
React is an open-source front-end JavaScript library that is used for building user interfaces, especially for single-page applications. It is used for handling view layer for web and mobile apps. React was created by Jordan Walke, a software engineer working for Facebook. React was first deployed on Facebook’s News Feed in 2011 and on Instagram in 2012. 	
The major features of React are:				
It uses VirtualDOM instead of RealDOM considering that Real- DOM manipulations are expensive.
 						
Supports server-side rendering.
 						
Follows Unidirectional data flow or data binding.
 						
Uses reusable/composable UI components to develop the view. 
 							

What is JSX?		
					
JSX is a XML-like syntax extension to ECMAScript (the acronym stands for JavaScript XML). Basically it just provides syntactic sugar for the React.createElement() function, giving us expressiveness of JavaScript along with HTML like template syntax.
					
In the example below text inside <h1> tag is returned as JavaScript func- tion to the render function. 

What is state in React?
State of a component is an object that holds some information that may change over the lifetime of the component. We should always try to make our state as simple as possible and minimise the number of stateful components.

const [state, setState] = React.useState( )
			
		
What is the difference between state and props?

There are two types of “model” data in React: props and state. The two are very different:
Props are like arguments you pass to a function. They let a parent component pass data to a child component and customize its appearance. For example, a Form can pass a color prop to a Button.
State is like a component’s memory. It lets a component keep track of some information and change it in response to interactions. For example, a Button might keep track of isHovered state.
Props and state are different, but they work together. A parent component will often keep some information in state (so that it can change it), and pass it down to child components as their props. It’s okay if the difference still feels fuzzy on the first read. It takes a bit of practice for it to really stick!
What is Strict Mode in React?
React there are three kinds of inputs that you can read while rendering: props, state, and context. You should always treat these inputs as read-only.
When you want to change something in response to user input, you should set state instead of writing to a variable. You should never change preexisting variables or objects while your component is rendering.
React offers a “Strict Mode” in which it calls each component’s function twice during development. By calling the component functions twice, Strict Mode helps find components that break these rules.
Notice how the original example displayed “Guest #2”, “Guest #4”, and “Guest #6” instead of “Guest #1”, “Guest #2”, and “Guest #3”. The original function was impure, so calling it twice broke it. But the fixed pure version works even if the function is called twice every time. Pure functions only calculate, so calling them twice won’t change anything—just like calling double(2) twice doesn’t change what’s returned, and solving y = 2x twice doesn’t change what y is. Same inputs, same outputs. Always.
Strict Mode has no effect in production, so it won’t slow down the app for your users. To opt into Strict Mode, you can wrap your root component into <React.StrictMode>. Some frameworks do this by default.

How does React.useState know what the current state is?
You might have noticed that the useState call does not receive any information about which state variable it refers to. There is no “identifier” that is passed to useState, so how does it know which of the state variables to return? Does it rely on some magic like parsing your functions? The answer is no.
Instead, to enable their concise syntax, Hooks rely on a stable call order on every render of the same component. This works well in practice because if you follow the rule above (“only call Hooks at the top level”), Hooks will always be called in the same order. Additionally, a linter plugin catches most mistakes.
Internally, React holds an array of state pairs for every component. It also maintains the current pair index, which is set to 0 before rendering. Each time you call useState, React gives you the next state pair and increments the index. You can read more about this mechanism in React Hooks: Not Magic, Just Arrays.

Why is mutating state not recommended in React?
There are a few reasons:
Debugging: If you use console.log and don’t mutate state, your past logs won’t get clobbered by the more recent state changes. So you can clearly see how state has changed between renders.
Optimizations: Common React optimization strategies rely on skipping work if previous props or state are the same as the next ones. If you never mutate state, it is very fast to check whether there were any changes. If prevObj === obj, you can be sure that nothing could have changed inside of it.
New Features: The new React features we’re building rely on state being treated like a snapshot. If you’re mutating past versions of state, that may prevent you from using the new features.
Requirement Changes: Some application features, like implementing Undo/Redo, showing a history of changes, or letting the user reset a form to earlier values, are easier to do when nothing is mutated. This is because you can keep past copies of state in memory, and reuse them when appropriate. If you start with a mutative approach, features like this can be difficult to add later on.
Simpler Implementation: Because React does not rely on mutation, it does not need to do anything special with your objects. It does not need to hijack their properties, always wrap them into Proxies, or do other work at initialization as many “reactive” solutions do. This is also why React lets you put any object into state—no matter how large—without additional performance or correctness pitfalls.

Is mirroring a prop as a state a good thing? Ie, setting prop from a parent component to a child component.

A common example of redundant state is code like this:
function Message({ messageColor }) {
 const [color, setColor] = useState(messageColor);
Here, a color state variable is initialized to the messageColor prop. The problem is that if the parent component passes a different value of messageColor later (for example, 'red' instead of 'blue'), the color state variable would not be updated! The state is only initialized during the first render.
This is why “mirroring” some prop in a state variable can lead to confusion. Instead, use the messageColor prop directly in your code. If you want to give it a shorter name, use a constant:
function Message({ messageColor }) {
 const color = messageColor;
This way it won’t get out of sync with the prop passed from the parent component.
“Mirroring” props into state only makes sense when you want to ignore all updates for a specific prop. By convention, start the prop name with initial or default to clarify that its new values are ignored:
function Message({ initialColor }) {
 // The `color` state variable holds the *first* value of `initialColor`.
 // Further changes to the `initialColor` prop are ignored.
 const [color, setColor] = useState(initialColor);



How do you lift state up?


If you need to share state between two components, you need to lift the state up to a common ancestor in the tree. This will ensure that you have a single source of truth, ( no duplicacy ) and the state can flow into each of the components, if you need to update the state, the setState dispatchers can be shared to whichever component that is required.

In a React application, many components will have their own state. Some state may “live” close to the leaf components (components at the bottom of the tree) like inputs. Other state may “live” closer to the top of the app. For example, even client-side routing libraries are usually implemented by storing the current route in the React state, and passing it down by props!
For each unique piece of state, you will choose the component that “owns” it. This principle is also known as having a “single source of truth.” It doesn’t mean that all state lives in one place—but that for each piece of state, there is a specific component that holds that piece of information. Instead of duplicating shared state between components, you will lift it up to their common shared parent, and pass it down to the children that need it.
Your app will change as you work on it. It is common that you will move state down or back up while you’re still figuring out where each piece of the state “lives”. This is all part of the process!


What are controlled and uncontrolled components?

It is common to call a component with some local state “uncontrolled”. For example, the original Panel component with an isActive state variable is uncontrolled because its parent cannot influence whether the panel is active or not.
In contrast, you might say a component is “controlled” when the important information in it is driven by props rather than its own local state. This lets the parent component fully specify its behavior. The final Panel component with the isActive prop is controlled by the Accordion component.
Uncontrolled components are easier to use within their parents because they require less configuration. But they’re less flexible when you want to coordinate them together. Controlled components are maximally flexible, but they require the parent components to fully configure them with props.
In practice, “controlled” and “uncontrolled” aren’t strict technical terms—each component usually has some mix of both local state and props. However, this is a useful way to talk about how components are designed and what capabilities they offer.
When writing a component, consider which information in it should be controlled (via props), and which information should be uncontrolled (via state). But you can always change your mind and refactor later.
What is the difference between useState and useReducer?

Code size: Generally, with useState you have to write less code upfront. With useReducer, you have to write both a reducer function and dispatch actions. However, useReducer can help cut down on the code if many event handlers modify state in a similar way.
Readability: useState is very easy to read when the state updates are simple. When they get more complex, they can bloat your component’s code and make it difficult to scan. In this case, useReducer lets you cleanly separate the how of update logic from the what happened of event handlers.
Debugging: When you have a bug with useState, it can be difficult to tell where the state was set incorrectly, and why. With useReducer, you can add a console log into your reducer to see every state update, and why it happened (due to which action). If each action is correct, you’ll know that the mistake is in the reducer logic itself. However, you have to step through more code than with useState.
Testing: A reducer is a pure function that doesn’t depend on your component. This means that you can export and test it separately in isolation. While generally it’s best to test components in a more realistic environment, for complex state update logic it can be useful to assert that your reducer returns a particular state for a particular initial state and action.
Keep these two tips in mind when writing reducers:
Reducers must be pure. Similar to state updater functions, reducers run during rendering! (Actions are queued until the next render.) This means that reducers must be pure—same inputs always result in the same output. They should not send requests, schedule timeouts, or perform any side effects (operations that impact things outside the component). They should update objects and arrays without mutations.
Each action describes a single user interaction, even if that leads to multiple changes in the data. For example, if a user presses “Reset” on a form with five fields managed by a reducer, it makes more sense to dispatch one reset_form action rather than five separate set_field actions. If you log every action in a reducer, that log should be clear enough for you to reconstruct what interactions or responses happened in what order. This helps with debugging!
 

What is Context API?



Prop drilling

Context lets a component provide some information to the entire tree below it.
To pass context:
Create and export it with export const MyContext = createContext(defaultValue).
Pass it to the useContext(MyContext) Hook to read it in any child component, no matter how deep.
Wrap children into <MyContext.Provider value={...}> to provide it from a parent.
Context passes through any components in the middle.
Context lets you write components that “adapt to their surroundings.”
Before you use context, try passing props or passing JSX as children.
Theming: If your app lets the user change its appearance (e.g. dark mode), you can put a context provider at the top of your app, and use that context in components that need to adjust their visual look.
Current account: Many components might need to know the currently logged in user. Putting it in context makes it convenient to read it anywhere in the tree. Some apps also let you operate multiple accounts at the same time (e.g. to leave a comment as a different user). In those cases, it can be convenient to wrap a part of the UI into a nested provider with a different current account value.
Routing: Most routing solutions use context internally to hold the current route. This is how every link “knows” whether it’s active or not. If you build your own router, you might want to do it too.
Managing state: As your app grows, you might end up with a lot of state closer to the top of your app. Many distant components below may want to change it. It is common to use a reducer together with context to manage complex state and pass it down to distant components without too much hassle.
Context is not limited to static values. If you pass a different value on the next render, React will update all the components reading it below! This is why context is often used in combination with state.
In general, if some information is needed by distant components in different parts of the tree, it’s a good indication that context will help you.

How can you use useContext and useReducer together?


You can combine reducer with context to let any component read and update state above it.
To provide state and the dispatch function to components below:
Create two contexts (for state and for dispatch functions).
Provide both contexts from the component that uses the reducer.
Use either context from components that need to read them.
You can further declutter the components by moving all wiring into one file.
You can export a component like TasksProvider that provides context.
You can also export custom Hooks like useTasks and useTasksDispatch to read it.
You can have many context-reducer pairs like this in your app.

What is the difference between useRef and useState?


refs
state
useRef(initialValue) returns { current: initialValue }
useState(initialValue) returns the current value of a state variable and a state setter function ( [value, setValue])
Doesn’t trigger re-render when you change it.
Triggers re-render when you change it.
Mutable—you can modify and update current’s value outside of the rendering process.
“Immutable”—you must use the state setting function to modify state variables to queue a re-render.
You shouldn’t read (or write) the current value during rendering.
You can read state at any time. However, each render has its own snapshot of state which does not change.


Although both useState and useRef are provided by React, in principle useRef could be implemented on top of useState. You can imagine that inside of React, useRef is implemented like this:
// Inside of React
function useRef(initialValue) {
 const [ref, unused] = useState({ current: initialValue });
 return ref;
}
During the first render, useRef returns { current: initialValue }. This object is stored by React, so during the next render the same object will be returned. Note how the state setter is unused in this example. It is unnecessary because useRef always needs to return the same object!
React provides a built-in version of useRef because it is common enough in practice. But you can think of it as a regular state variable without a setter. If you’re familiar with object-oriented programming, refs might remind you of instance fields—but instead of this.something you write somethingRef.current.
Typically, you will use a ref when your component needs to “step outside” React and communicate with external APIs—often a browser API that won’t impact the appearance of the component. Here are a few of these rare situations:
Storing timeout IDs
Storing and manipulating DOM elements, which we cover on the next page
Storing other objects that aren’t necessary to calculate the JSX.
If your component needs to store some value, but it doesn’t impact the rendering logic, choose refs.
Refs are an escape hatch to hold onto values that aren’t used for rendering. You won’t need them often.
A ref is a plain JavaScript object with a single property called current, which you can read or set.
You can ask React to give you a ref by calling the useRef Hook.
Like state, refs let you retain information between re-renders of a component.
Unlike state, setting the ref’s current value does not trigger a re-render.
Don’t read or write ref.current during rendering. This makes your component hard to predict.
How to manage a list of refs using a ref callback?

This is because Hooks must only be called at the top-level of your component. You can’t call useRef in a loop, in a condition, or inside a map() call.
One possible way around this is to get a single ref to their parent element, and then use DOM manipulation methods like querySelectorAll to “find” the individual child nodes from it. However, this is brittle and can break if your DOM structure changes.
Another solution is to pass a function to the ref attribute. This is called a “ref callback”. React will call your ref callback with the DOM node when it’s time to set the ref, and with null when it’s time to clear it. This lets you maintain your own array or a Map, and access any ref by its index or some kind of ID.


What does useState do?

useState(initialState)
Call useState at the top level of your component to declare a state variable.
import { useState } from 'react';
 
function MyComponent() {
 const [age, setAge] = useState(28);
 const [name, setName] = useState('Taylor');
 const [todos, setTodos] = useState(() => createTodos());
 // ...
The convention is to name state variables like [something, setSomething] using array destructuring.
See more examples above.
Parameters
initialState: The value you want the state to be initially. It can be a value of any type, but there is a special behavior for functions. This argument is ignored after the initial render.
If you pass a function as initialState, it will be treated as an initializer function. It should be pure, should take no arguments, and should return a value of any type. React will call your initializer function when initializing the component, and store its return value as the initial state. See an example above.
Returns
useState returns an array with exactly two values:
The current state. During the first render, it will match the initialState you have passed.
The set function that lets you update the state to a different value and trigger a re-render.
Caveats
useState is a Hook, so you can only call it at the top level of your component or your own Hooks. You can’t call it inside loops or conditions. If you need that, extract a new component and move the state into it.
In Strict Mode, React will call your initializer function twice in order to help you find accidental impurities. This is development-only behavior and does not affect production. If your initializer function is pure (as it should be), this should not affect the logic of your component. The result from one of the calls will be ignored.

set functions, like setSomething(nextState)
The set function returned by useState lets you update the state to a different value and trigger a re-render. You can pass the next state directly, or a function that calculates it from the previous state:
const [name, setName] = useState('Edward');
 
function handleClick() {
 setName('Taylor');
 setAge(a => a + 1);
 // ...
Parameters
nextState: The value that you want the state to be. It can be a value of any type, but there is a special behavior for functions.
If you pass a function as nextState, it will be treated as an updater function. It must be pure, should take the pending state as its only argument, and should return the next state. React will put your updater function in a queue and re-render your component. During the next render, React will calculate the next state by applying all of the queued updaters to the previous state. See an example above.
Returns
set functions do not have a return value.
Caveats
The set function only updates the state variable for the next render. If you read the state variable after calling the set function, you will still get the old value that was on the screen before your call.
If the new value you provide is identical to the current state, as determined by an Object.is comparison, React will skip re-rendering the component and its children. This is an optimization. Although in some cases React may still need to call your component before skipping the children, it shouldn’t affect your code.
React batches state updates. It updates the screen after all the event handlers have run and have called their set functions. This prevents multiple re-renders during a single event. In the rare case that you need to force React to update the screen earlier, for example to access the DOM, you can use flushSync.
Calling the set function during rendering is only allowed from within the currently rendering component. React will discard its output and immediately attempt to render it again with the new state. This pattern is rarely needed, but you can use it to store information from the previous renders. See an example above.
In Strict Mode, React will call your updater function twice in order to help you find accidental impurities. This is development-only behavior and does not affect production. If your updater function is pure (as it should be), this should not affect the logic of your component. The result from one of the calls will be ignored.


What does usesEffect do?
useEffect(didUpdate);
Accepts a function that contains imperative, possibly effectful code.
Mutations, subscriptions, timers, logging, and other side effects are not allowed inside the main body of a function component (referred to as React’s render phase). Doing so will lead to confusing bugs and inconsistencies in the UI.
Instead, use useEffect. The function passed to useEffect will run after the render is committed to the screen. Think of effects as an escape hatch from React’s purely functional world into the imperative world.
By default, effects run after every completed render, but you can choose to fire them only when certain values have changed.
Cleaning up an effect
Often, effects create resources that need to be cleaned up before the component leaves the screen, such as a subscription or timer ID. To do this, the function passed to useEffect may return a clean-up function. For example, to create a subscription:
useEffect(() => {
  const subscription = props.source.subscribe();
  return () => {
    // Clean up the subscription
    subscription.unsubscribe();
  };
The clean-up function runs before the component is removed from the UI to prevent memory leaks. Additionally, if a component renders multiple times (as they typically do), the previous effect is cleaned up before executing the next effect. In our example, this means a new subscription is created on every update. To avoid firing an effect on every update, refer to the next section.

What are dependency arrays?

The default behavior for effects is to fire the effect after every completed render. That way an effect is always recreated if one of its dependencies changes.
However, this may be overkill in some cases, like the subscription example from the previous section. We don’t need to create a new subscription on every update, only if the source prop has changed.
To implement this, pass a second argument to useEffect that is the array of values that the effect depends on. Our updated example now looks like this:
useEffect(
  () => {
    const subscription = props.source.subscribe();
    return () => {
      subscription.unsubscribe();
    };
  },
  [props.source],
Now the subscription will only be recreated when props.source changes.


What are lice cycle methods or phases in React?


https://github.com/Wavez/react-hooks-lifecycle

For class components

The component lifecycle has three distinct lifecycle phases:
Mounting: The component is ready to mount in the browser DOM. This phase covers initialization from constructor(), getDerivedStateFromProps(), render(), and componentDidMount() lifecycle methods.
Updating: In this phase, the component gets updated in two ways, sending the new props and updating the state either from setState() or forceUpdate(). This phase covers getDerivedStateFromProps(), shouldComponentUpdate(), render(), getSnapshotBeforeUpdate() and componentDidUpdate() lifecycle methods.
Unmounting: In this last phase, the component is not needed and gets unmounted from the browser DOM. This phase includes componentWillUnmount() lifecycle method.
It's worth mentioning that React internally has a concept of phases when applying changes to the DOM. They are separated as follows
Render The component will render without any side effects. This applies to Pure components and in this phase, React can pause, abort, or restart the render.
Pre-commit Before the component actually applies the changes to the DOM, there is a moment that allows React to read from the DOM through the getSnapshotBeforeUpdate().
Commit React works with the DOM and executes the final lifecycles respectively componentDidMount() for mounting, componentDidUpdate() for updating, and componentWillUnmount() for unmounting.


https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/

What is the Virtual DOM?

The virtual DOM (VDOM) is a programming concept where an ideal, or “virtual”, representation of a UI is kept in memory and synced with the “real” DOM by a library such as ReactDOM. This process is called reconciliation.
This approach enables the declarative API of React: You tell React what state you want the UI to be in, and it makes sure the DOM matches that state. This abstracts out the attribute manipulation, event handling, and manual DOM updating that you would otherwise have to use to build your app.
Since “virtual DOM” is more of a pattern than a specific technology, people sometimes say it to mean different things. In React world, the term “virtual DOM” is usually associated with React elements since they are the objects representing the user interface. React, however, also uses internal objects called “fibers” to hold additional information about the component tree. They may also be considered a part of “virtual DOM” implementation in React.


When you use React, at a single point in time you can think of the render() function as creating a tree of React elements. On the next state or props update, that render() function will return a different tree of React elements. React then needs to figure out how to efficiently update the UI to match the most recent tree.
There are some generic solutions to this algorithmic problem of generating the minimum number of operations to transform one tree into another. However, the state of the art algorithms have a complexity in the order of O(n3) where n is the number of elements in the tree.
If we used this in React, displaying 1000 elements would require in the order of one billion comparisons. This is far too expensive. Instead, React implements a heuristic O(n) algorithm.
Whenever any underlying data changes, the entire UI is re-rendered in Virtual DOM representation.
Then the difference between the previous DOM representation and the new one is calculated.
Once the calculations are done, the real DOM will be updated with only the things that have actually changed.

Keys should be stable, predictable, and unique. Unstable keys (like those produced by Math.random()) will cause many component instances and DOM nodes to be unnecessarily recreated, which can cause performance degradation and lost state in child components.

